//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    accountGet(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processAccountGet(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    active(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    id(id: number): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    token(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/user/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processToken(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    usernameGet(userName: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsernameGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsernameGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processUsernameGet(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    usernameDelete(userName: string): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsernameDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsernameDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUsernameDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    role(role: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/role/{role}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    claim(issuer: string, originalIssuer: string, properties: { [key: string]: string; }, subject_AuthenticationType: string, subject_IsAuthenticated: boolean, subject_Actor_AuthenticationType: string, subject_Actor_IsAuthenticated: boolean, subject_Actor_Actor: ClaimsIdentity, subject_Actor_BootstrapContext: any, subject_Actor_Claims: Claim[], subject_Actor_Label: string, subject_Actor_Name: string, subject_Actor_NameClaimType: string, subject_Actor_RoleClaimType: string, subject_BootstrapContext: any, subject_Claims: Claim[], subject_Label: string, subject_Name: string, subject_NameClaimType: string, subject_RoleClaimType: string, type: string, value: string, valueType: string, claim: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/claim/{claim}";
        if (issuer === undefined || issuer === null)
            throw new Error("The parameter 'issuer' must be defined.");
        url_ = url_.replace("{Issuer}", encodeURIComponent("" + issuer));
        if (originalIssuer === undefined || originalIssuer === null)
            throw new Error("The parameter 'originalIssuer' must be defined.");
        url_ = url_.replace("{OriginalIssuer}", encodeURIComponent("" + originalIssuer));
        if (properties === undefined || properties === null)
            throw new Error("The parameter 'properties' must be defined.");
        url_ = url_.replace("{Properties}", encodeURIComponent("" + properties));
        if (subject_AuthenticationType === undefined || subject_AuthenticationType === null)
            throw new Error("The parameter 'subject_AuthenticationType' must be defined.");
        url_ = url_.replace("{Subject.AuthenticationType}", encodeURIComponent("" + subject_AuthenticationType));
        if (subject_IsAuthenticated === undefined || subject_IsAuthenticated === null)
            throw new Error("The parameter 'subject_IsAuthenticated' must be defined.");
        url_ = url_.replace("{Subject.IsAuthenticated}", encodeURIComponent("" + subject_IsAuthenticated));
        if (subject_Actor_AuthenticationType === undefined || subject_Actor_AuthenticationType === null)
            throw new Error("The parameter 'subject_Actor_AuthenticationType' must be defined.");
        url_ = url_.replace("{Subject.Actor.AuthenticationType}", encodeURIComponent("" + subject_Actor_AuthenticationType));
        if (subject_Actor_IsAuthenticated === undefined || subject_Actor_IsAuthenticated === null)
            throw new Error("The parameter 'subject_Actor_IsAuthenticated' must be defined.");
        url_ = url_.replace("{Subject.Actor.IsAuthenticated}", encodeURIComponent("" + subject_Actor_IsAuthenticated));
        if (subject_Actor_Actor === undefined || subject_Actor_Actor === null)
            throw new Error("The parameter 'subject_Actor_Actor' must be defined.");
        url_ = url_.replace("{Subject.Actor.Actor}", encodeURIComponent("" + subject_Actor_Actor));
        if (subject_Actor_BootstrapContext === undefined || subject_Actor_BootstrapContext === null)
            throw new Error("The parameter 'subject_Actor_BootstrapContext' must be defined.");
        url_ = url_.replace("{Subject.Actor.BootstrapContext}", encodeURIComponent("" + subject_Actor_BootstrapContext));
        if (subject_Actor_Claims === undefined || subject_Actor_Claims === null)
            throw new Error("The parameter 'subject_Actor_Claims' must be defined.");
        url_ = url_.replace("{Subject.Actor.Claims}", encodeURIComponent(subject_Actor_Claims.join()));
        if (subject_Actor_Label === undefined || subject_Actor_Label === null)
            throw new Error("The parameter 'subject_Actor_Label' must be defined.");
        url_ = url_.replace("{Subject.Actor.Label}", encodeURIComponent("" + subject_Actor_Label));
        if (subject_Actor_Name === undefined || subject_Actor_Name === null)
            throw new Error("The parameter 'subject_Actor_Name' must be defined.");
        url_ = url_.replace("{Subject.Actor.Name}", encodeURIComponent("" + subject_Actor_Name));
        if (subject_Actor_NameClaimType === undefined || subject_Actor_NameClaimType === null)
            throw new Error("The parameter 'subject_Actor_NameClaimType' must be defined.");
        url_ = url_.replace("{Subject.Actor.NameClaimType}", encodeURIComponent("" + subject_Actor_NameClaimType));
        if (subject_Actor_RoleClaimType === undefined || subject_Actor_RoleClaimType === null)
            throw new Error("The parameter 'subject_Actor_RoleClaimType' must be defined.");
        url_ = url_.replace("{Subject.Actor.RoleClaimType}", encodeURIComponent("" + subject_Actor_RoleClaimType));
        if (subject_BootstrapContext === undefined || subject_BootstrapContext === null)
            throw new Error("The parameter 'subject_BootstrapContext' must be defined.");
        url_ = url_.replace("{Subject.BootstrapContext}", encodeURIComponent("" + subject_BootstrapContext));
        if (subject_Claims === undefined || subject_Claims === null)
            throw new Error("The parameter 'subject_Claims' must be defined.");
        url_ = url_.replace("{Subject.Claims}", encodeURIComponent(subject_Claims.join()));
        if (subject_Label === undefined || subject_Label === null)
            throw new Error("The parameter 'subject_Label' must be defined.");
        url_ = url_.replace("{Subject.Label}", encodeURIComponent("" + subject_Label));
        if (subject_Name === undefined || subject_Name === null)
            throw new Error("The parameter 'subject_Name' must be defined.");
        url_ = url_.replace("{Subject.Name}", encodeURIComponent("" + subject_Name));
        if (subject_NameClaimType === undefined || subject_NameClaimType === null)
            throw new Error("The parameter 'subject_NameClaimType' must be defined.");
        url_ = url_.replace("{Subject.NameClaimType}", encodeURIComponent("" + subject_NameClaimType));
        if (subject_RoleClaimType === undefined || subject_RoleClaimType === null)
            throw new Error("The parameter 'subject_RoleClaimType' must be defined.");
        url_ = url_.replace("{Subject.RoleClaimType}", encodeURIComponent("" + subject_RoleClaimType));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{Type}", encodeURIComponent("" + type));
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{Value}", encodeURIComponent("" + value));
        if (valueType === undefined || valueType === null)
            throw new Error("The parameter 'valueType' must be defined.");
        url_ = url_.replace("{ValueType}", encodeURIComponent("" + valueType));
        if (claim === undefined || claim === null)
            throw new Error("The parameter 'claim' must be defined.");
        url_ = url_.replace("{claim}", encodeURIComponent("" + claim));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processClaim(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkEmail(body: RequestCheckEmailDTO | undefined): Observable<CheckEmailDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register/checkEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckEmailDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckEmailDTOBaseResponseDTO>;
        }));
    }

    protected processCheckEmail(response: HttpResponseBase): Observable<CheckEmailDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckEmailDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkUsername(body: RequestCheckUserNameDTO | undefined): Observable<CheckUserNameDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register/checkUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckUserNameDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckUserNameDTOBaseResponseDTO>;
        }));
    }

    protected processCheckUsername(response: HttpResponseBase): Observable<CheckUserNameDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckUserNameDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    register(body: CreateUserDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ReadUserDTOBaseResponseDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: UpdateUserDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/user/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = ObjectBaseResponseDTO.fromJS(resultData204);
            return _observableOf(result204);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    passwordKeycodePost(body: RequestKeycodeDTO | undefined): Observable<ResponseGenerateKeycodeDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/password/keycode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordKeycodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordKeycodePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseGenerateKeycodeDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseGenerateKeycodeDTOBaseResponseDTO>;
        }));
    }

    protected processPasswordKeycodePost(response: HttpResponseBase): Observable<ResponseGenerateKeycodeDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseGenerateKeycodeDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailKeycodePost(body: RequestKeycodeDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/email/keycode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailKeycodePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailKeycodePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processEmailKeycodePost(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmEmail(body: ConfirmAccountEmailDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/email/confirmEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reset(body: ResetPasswordDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/password/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    accountDelete(id: number): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processAccountDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AgeRangeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    ageRange(): Observable<AgeRangeDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/AgeRange";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgeRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgeRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgeRangeDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgeRangeDtoBaseResponseDTO>;
        }));
    }

    protected processAgeRange(response: HttpResponseBase): Observable<AgeRangeDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgeRangeDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AlgorithmClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param count (optional) 
     * @param language (optional) 
     * @return Success
     */
    algorithm(page: number | undefined, count: number | undefined, language: string | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Algorithm?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlgorithm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlgorithm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processAlgorithm(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    username(body: LoginRequestByUserNameDTO | undefined): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/username";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processUsername(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    email(body: LoginRequestByEmailDTO | undefined): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processEmail(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    refresh(): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthorizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    role(): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userPost(body: AddUserToRoleDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUserPost(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userDelete(body: RemoveUserFromRoleDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUserDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChildClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    id(id: number): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    childGet(): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildGet(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    childPost(body: CreateChildDto | undefined): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildPost(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    childPut(body: ChildDto | undefined): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildPut(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    childDelete(id: number): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildDelete(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GenderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    gender(): Observable<GenderDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Gender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGender(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenderDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenderDtoBaseResponseDTO>;
        }));
    }

    protected processGender(response: HttpResponseBase): Observable<GenderDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenderDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MovieClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    id(movieId: number, language: string | undefined): Observable<MovieDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Movie/id/{movieId}?";
        if (movieId === undefined || movieId === null)
            throw new Error("The parameter 'movieId' must be defined.");
        url_ = url_.replace("{movieId}", encodeURIComponent("" + movieId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDTOBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<MovieDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @return Success
     */
    movie(name: string | undefined, language: string | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Movie?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMovie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMovie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processMovie(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PlatformClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    platform(): Observable<Platform[]> {
        let url_ = this.baseUrl + "/v1/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlatform(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Platform[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Platform[]>;
        }));
    }

    protected processPlatform(response: HttpResponseBase): Observable<Platform[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Platform.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param count (optional) 
     * @param language (optional) 
     * @return Success
     */
    reviewGet(page: number | undefined, count: number | undefined, language: string | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReviewGet(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reviewPost(body: CreateReviewDto | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReviewPost(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AddUserToRoleDTO implements IAddUserToRoleDTO {
    roleName!: string;
    userName!: string;

    constructor(data?: IAddUserToRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): AddUserToRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IAddUserToRoleDTO {
    roleName: string;
    userName: string;
}

export class AgeRange implements IAgeRange {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    initialAge?: number;
    finalAge?: number;
    children?: PersonChild[] | null;

    constructor(data?: IAgeRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.initialAge = _data["initialAge"] !== undefined ? _data["initialAge"] : <any>null;
            this.finalAge = _data["finalAge"] !== undefined ? _data["finalAge"] : <any>null;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
        }
    }

    static fromJS(data: any): AgeRange {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["initialAge"] = this.initialAge !== undefined ? this.initialAge : <any>null;
        data["finalAge"] = this.finalAge !== undefined ? this.finalAge : <any>null;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgeRange {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    initialAge?: number;
    finalAge?: number;
    children?: PersonChild[] | null;
}

export class AgeRangeDto implements IAgeRangeDto {
    id?: number;
    initialAge?: number;
    finalAge?: number;

    constructor(data?: IAgeRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.initialAge = _data["initialAge"] !== undefined ? _data["initialAge"] : <any>null;
            this.finalAge = _data["finalAge"] !== undefined ? _data["finalAge"] : <any>null;
        }
    }

    static fromJS(data: any): AgeRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["initialAge"] = this.initialAge !== undefined ? this.initialAge : <any>null;
        data["finalAge"] = this.finalAge !== undefined ? this.finalAge : <any>null;
        return data;
    }
}

export interface IAgeRangeDto {
    id?: number;
    initialAge?: number;
    finalAge?: number;
}

export class AgeRangeDtoBaseResponseDTO implements IAgeRangeDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: AgeRangeDto[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IAgeRangeDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(AgeRangeDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): AgeRangeDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRangeDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IAgeRangeDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: AgeRangeDto[] | null;
    errors?: string[] | null;
}

export class ApplicationUser implements IApplicationUser {
    id?: number;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | null;
    lastName?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.normalizedUserName = _data["normalizedUserName"] !== undefined ? _data["normalizedUserName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.normalizedEmail = _data["normalizedEmail"] !== undefined ? _data["normalizedEmail"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.passwordHash = _data["passwordHash"] !== undefined ? _data["passwordHash"] : <any>null;
            this.securityStamp = _data["securityStamp"] !== undefined ? _data["securityStamp"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = _data["twoFactorEnabled"] !== undefined ? _data["twoFactorEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.accessFailedCount = _data["accessFailedCount"] !== undefined ? _data["accessFailedCount"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["normalizedUserName"] = this.normalizedUserName !== undefined ? this.normalizedUserName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["normalizedEmail"] = this.normalizedEmail !== undefined ? this.normalizedEmail : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["securityStamp"] = this.securityStamp !== undefined ? this.securityStamp : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["accessFailedCount"] = this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IApplicationUser {
    id?: number;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | null;
    lastName?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
}

export class Award implements IAward {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    price?: number;
    value?: number;
    awardPerson?: AwardPerson[] | null;

    constructor(data?: IAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            if (Array.isArray(_data["awardPerson"])) {
                this.awardPerson = [] as any;
                for (let item of _data["awardPerson"])
                    this.awardPerson!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awardPerson = <any>null;
            }
        }
    }

    static fromJS(data: any): Award {
        data = typeof data === 'object' ? data : {};
        let result = new Award();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        if (Array.isArray(this.awardPerson)) {
            data["awardPerson"] = [];
            for (let item of this.awardPerson)
                data["awardPerson"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAward {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    price?: number;
    value?: number;
    awardPerson?: AwardPerson[] | null;
}

export class AwardPerson implements IAwardPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    awardId?: number;
    person?: Person;
    review?: Review;
    award?: Award;

    constructor(data?: IAwardPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.awardId = _data["awardId"] !== undefined ? _data["awardId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
            this.award = _data["award"] ? Award.fromJS(_data["award"]) : <any>null;
        }
    }

    static fromJS(data: any): AwardPerson {
        data = typeof data === 'object' ? data : {};
        let result = new AwardPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["awardId"] = this.awardId !== undefined ? this.awardId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["award"] = this.award ? this.award.toJSON() : <any>null;
        return data;
    }
}

export interface IAwardPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    awardId?: number;
    person?: Person;
    review?: Review;
    award?: Award;
}

export class CheckEmailDTO implements ICheckEmailDTO {
    readonly isEmailValid?: boolean;

    constructor(data?: ICheckEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isEmailValid = _data["isEmailValid"] !== undefined ? _data["isEmailValid"] : <any>null;
        }
    }

    static fromJS(data: any): CheckEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailValid"] = this.isEmailValid !== undefined ? this.isEmailValid : <any>null;
        return data;
    }
}

export interface ICheckEmailDTO {
    isEmailValid?: boolean;
}

export class CheckEmailDTOBaseResponseDTO implements ICheckEmailDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: CheckEmailDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: ICheckEmailDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CheckEmailDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): CheckEmailDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ICheckEmailDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: CheckEmailDTO[] | null;
    errors?: string[] | null;
}

export class CheckUserNameDTO implements ICheckUserNameDTO {
    isUserNameValid?: boolean;

    constructor(data?: ICheckUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameValid = _data["isUserNameValid"] !== undefined ? _data["isUserNameValid"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameValid"] = this.isUserNameValid !== undefined ? this.isUserNameValid : <any>null;
        return data;
    }
}

export interface ICheckUserNameDTO {
    isUserNameValid?: boolean;
}

export class CheckUserNameDTOBaseResponseDTO implements ICheckUserNameDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: CheckUserNameDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: ICheckUserNameDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CheckUserNameDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): CheckUserNameDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserNameDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ICheckUserNameDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: CheckUserNameDTO[] | null;
    errors?: string[] | null;
}

export class ChildDto implements IChildDto {
    id?: number;
    ageRangeId?: number;
    genderId?: number;
    personId?: number;

    constructor(data?: IChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
        }
    }

    static fromJS(data: any): ChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        return data;
    }
}

export interface IChildDto {
    id?: number;
    ageRangeId?: number;
    genderId?: number;
    personId?: number;
}

export class ChildDtoBaseResponseDTO implements IChildDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ChildDto[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IChildDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ChildDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ChildDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IChildDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ChildDto[] | null;
    errors?: string[] | null;
}

export class Claim implements IClaim {
    readonly issuer?: string | null;
    readonly originalIssuer?: string | null;
    readonly properties?: { [key: string]: string; } | null;
    subject?: ClaimsIdentity;
    readonly type?: string | null;
    readonly value?: string | null;
    readonly valueType?: string | null;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuer = _data["issuer"] !== undefined ? _data["issuer"] : <any>null;
            (<any>this).originalIssuer = _data["originalIssuer"] !== undefined ? _data["originalIssuer"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] !== undefined ? _data["properties"][key] : <any>null;
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>null;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : <any>null;
            (<any>this).value = _data["value"] !== undefined ? _data["value"] : <any>null;
            (<any>this).valueType = _data["valueType"] !== undefined ? _data["valueType"] : <any>null;
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer !== undefined ? this.issuer : <any>null;
        data["originalIssuer"] = this.originalIssuer !== undefined ? this.originalIssuer : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["valueType"] = this.valueType !== undefined ? this.valueType : <any>null;
        return data;
    }
}

export interface IClaim {
    issuer?: string | null;
    originalIssuer?: string | null;
    properties?: { [key: string]: string; } | null;
    subject?: ClaimsIdentity;
    type?: string | null;
    value?: string | null;
    valueType?: string | null;
}

export class ClaimsIdentity implements IClaimsIdentity {
    readonly authenticationType?: string | null;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | null;
    readonly claims?: Claim[] | null;
    label?: string | null;
    readonly name?: string | null;
    readonly nameClaimType?: string | null;
    readonly roleClaimType?: string | null;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).authenticationType = _data["authenticationType"] !== undefined ? _data["authenticationType"] : <any>null;
            (<any>this).isAuthenticated = _data["isAuthenticated"] !== undefined ? _data["isAuthenticated"] : <any>null;
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>null;
            this.bootstrapContext = _data["bootstrapContext"] !== undefined ? _data["bootstrapContext"] : <any>null;
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            else {
                (<any>this).claims = <any>null;
            }
            this.label = _data["label"] !== undefined ? _data["label"] : <any>null;
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).nameClaimType = _data["nameClaimType"] !== undefined ? _data["nameClaimType"] : <any>null;
            (<any>this).roleClaimType = _data["roleClaimType"] !== undefined ? _data["roleClaimType"] : <any>null;
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType !== undefined ? this.authenticationType : <any>null;
        data["isAuthenticated"] = this.isAuthenticated !== undefined ? this.isAuthenticated : <any>null;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>null;
        data["bootstrapContext"] = this.bootstrapContext !== undefined ? this.bootstrapContext : <any>null;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label !== undefined ? this.label : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nameClaimType"] = this.nameClaimType !== undefined ? this.nameClaimType : <any>null;
        data["roleClaimType"] = this.roleClaimType !== undefined ? this.roleClaimType : <any>null;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | null;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | null;
    claims?: Claim[] | null;
    label?: string | null;
    name?: string | null;
    nameClaimType?: string | null;
    roleClaimType?: string | null;
}

export class Comment implements IComment {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    parentComentId?: number | null;
    person?: Person;
    review?: Review;
    parentComment?: Comment;
    answers?: Comment[] | null;
    commentDetails?: CommentDetails[] | null;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.parentComentId = _data["parentComentId"] !== undefined ? _data["parentComentId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
            this.parentComment = _data["parentComment"] ? Comment.fromJS(_data["parentComment"]) : <any>null;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Comment.fromJS(item));
            }
            else {
                this.answers = <any>null;
            }
            if (Array.isArray(_data["commentDetails"])) {
                this.commentDetails = [] as any;
                for (let item of _data["commentDetails"])
                    this.commentDetails!.push(CommentDetails.fromJS(item));
            }
            else {
                this.commentDetails = <any>null;
            }
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["parentComentId"] = this.parentComentId !== undefined ? this.parentComentId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["parentComment"] = this.parentComment ? this.parentComment.toJSON() : <any>null;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.commentDetails)) {
            data["commentDetails"] = [];
            for (let item of this.commentDetails)
                data["commentDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IComment {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    parentComentId?: number | null;
    person?: Person;
    review?: Review;
    parentComment?: Comment;
    answers?: Comment[] | null;
    commentDetails?: CommentDetails[] | null;
}

export class CommentDetails implements ICommentDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    commentId?: number;
    text?: string | null;
    comment?: Comment;

    constructor(data?: ICommentDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>null;
        }
    }

    static fromJS(data: any): CommentDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>null;
        return data;
    }
}

export interface ICommentDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    commentId?: number;
    text?: string | null;
    comment?: Comment;
}

export class ConfirmAccountEmailDTO implements IConfirmAccountEmailDTO {
    userId!: number;
    keycode!: number;

    constructor(data?: IConfirmAccountEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.keycode = _data["keycode"] !== undefined ? _data["keycode"] : <any>null;
        }
    }

    static fromJS(data: any): ConfirmAccountEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAccountEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["keycode"] = this.keycode !== undefined ? this.keycode : <any>null;
        return data;
    }
}

export interface IConfirmAccountEmailDTO {
    userId: number;
    keycode: number;
}

export class Content implements IContent {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformCategoryId?: number;
    externalId?: string | null;
    platformCategory?: PlatformCategory;
    reviews?: Review[] | null;
    contentGenre?: ContentGenre[] | null;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.platformCategoryId = _data["platformCategoryId"] !== undefined ? _data["platformCategoryId"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.platformCategory = _data["platformCategory"] ? PlatformCategory.fromJS(_data["platformCategory"]) : <any>null;
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
            else {
                this.reviews = <any>null;
            }
            if (Array.isArray(_data["contentGenre"])) {
                this.contentGenre = [] as any;
                for (let item of _data["contentGenre"])
                    this.contentGenre!.push(ContentGenre.fromJS(item));
            }
            else {
                this.contentGenre = <any>null;
            }
        }
    }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["platformCategoryId"] = this.platformCategoryId !== undefined ? this.platformCategoryId : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["platformCategory"] = this.platformCategory ? this.platformCategory.toJSON() : <any>null;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.contentGenre)) {
            data["contentGenre"] = [];
            for (let item of this.contentGenre)
                data["contentGenre"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContent {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformCategoryId?: number;
    externalId?: string | null;
    platformCategory?: PlatformCategory;
    reviews?: Review[] | null;
    contentGenre?: ContentGenre[] | null;
}

export class ContentGenre implements IContentGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    contentId?: number;
    genreId?: number;
    content?: Content;
    genre?: Genre;

    constructor(data?: IContentGenre) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.genreId = _data["genreId"] !== undefined ? _data["genreId"] : <any>null;
            this.content = _data["content"] ? Content.fromJS(_data["content"]) : <any>null;
            this.genre = _data["genre"] ? Genre.fromJS(_data["genre"]) : <any>null;
        }
    }

    static fromJS(data: any): ContentGenre {
        data = typeof data === 'object' ? data : {};
        let result = new ContentGenre();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["genreId"] = this.genreId !== undefined ? this.genreId : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        data["genre"] = this.genre ? this.genre.toJSON() : <any>null;
        return data;
    }
}

export interface IContentGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    contentId?: number;
    genreId?: number;
    content?: Content;
    genre?: Genre;
}

export class CreateChildDto implements ICreateChildDto {
    ageRangeId?: number;
    genderId?: number;

    constructor(data?: ICreateChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface ICreateChildDto {
    ageRangeId?: number;
    genderId?: number;
}

export class CreateReviewDto implements ICreateReviewDto {
    contentId?: number | null;
    externalContentId?: string | null;
    platformId?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;

    constructor(data?: ICreateReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.externalContentId = _data["externalContentId"] !== undefined ? _data["externalContentId"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
        }
    }

    static fromJS(data: any): CreateReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["externalContentId"] = this.externalContentId !== undefined ? this.externalContentId : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        return data;
    }
}

export interface ICreateReviewDto {
    contentId?: number | null;
    externalContentId?: string | null;
    platformId?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;
}

export class CreateUserDTO implements ICreateUserDTO {
    userName!: string;
    password!: string;
    rePassword!: string;
    firstName!: string;
    lastName!: string;
    email!: string;
    personDetails!: PersonOnCreateUserDTO;

    constructor(data?: ICreateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personDetails = new PersonOnCreateUserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rePassword = _data["rePassword"] !== undefined ? _data["rePassword"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.personDetails = _data["personDetails"] ? PersonOnCreateUserDTO.fromJS(_data["personDetails"]) : new PersonOnCreateUserDTO();
        }
    }

    static fromJS(data: any): CreateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rePassword"] = this.rePassword !== undefined ? this.rePassword : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["personDetails"] = this.personDetails ? this.personDetails.toJSON() : <any>null;
        return data;
    }
}

export interface ICreateUserDTO {
    userName: string;
    password: string;
    rePassword: string;
    firstName: string;
    lastName: string;
    email: string;
    personDetails: PersonOnCreateUserDTO;
}

export class Gender implements IGender {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isBinary?: boolean;
    people?: Person[] | null;
    children?: PersonChild[] | null;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isBinary = _data["isBinary"] !== undefined ? _data["isBinary"] : <any>null;
            if (Array.isArray(_data["people"])) {
                this.people = [] as any;
                for (let item of _data["people"])
                    this.people!.push(Person.fromJS(item));
            }
            else {
                this.people = <any>null;
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isBinary"] = this.isBinary !== undefined ? this.isBinary : <any>null;
        if (Array.isArray(this.people)) {
            data["people"] = [];
            for (let item of this.people)
                data["people"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGender {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isBinary?: boolean;
    people?: Person[] | null;
    children?: PersonChild[] | null;
}

export class GenderDto implements IGenderDto {
    id?: number;
    name?: string | null;
    isBinary?: boolean;

    constructor(data?: IGenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isBinary = _data["isBinary"] !== undefined ? _data["isBinary"] : <any>null;
        }
    }

    static fromJS(data: any): GenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isBinary"] = this.isBinary !== undefined ? this.isBinary : <any>null;
        return data;
    }
}

export interface IGenderDto {
    id?: number;
    name?: string | null;
    isBinary?: boolean;
}

export class GenderDtoBaseResponseDTO implements IGenderDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: GenderDto[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IGenderDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(GenderDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): GenderDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GenderDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IGenderDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: GenderDto[] | null;
    errors?: string[] | null;
}

export class Genre implements IGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    contentGenre?: ContentGenre[] | null;

    constructor(data?: IGenre) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["contentGenre"])) {
                this.contentGenre = [] as any;
                for (let item of _data["contentGenre"])
                    this.contentGenre!.push(ContentGenre.fromJS(item));
            }
            else {
                this.contentGenre = <any>null;
            }
        }
    }

    static fromJS(data: any): Genre {
        data = typeof data === 'object' ? data : {};
        let result = new Genre();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.contentGenre)) {
            data["contentGenre"] = [];
            for (let item of this.contentGenre)
                data["contentGenre"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    contentGenre?: ContentGenre[] | null;
}

export class GenreDTO implements IGenreDTO {
    id?: number | null;
    name?: string | null;

    constructor(data?: IGenreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): GenreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IGenreDTO {
    id?: number | null;
    name?: string | null;
}

export class LoginRequestByEmailDTO implements ILoginRequestByEmailDTO {
    email!: string;
    password!: string;

    constructor(data?: ILoginRequestByEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestByEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestByEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestByEmailDTO {
    email: string;
    password: string;
}

export class LoginRequestByUserNameDTO implements ILoginRequestByUserNameDTO {
    userName!: string;
    password!: string;

    constructor(data?: ILoginRequestByUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestByUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestByUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestByUserNameDTO {
    userName: string;
    password: string;
}

export class MovieDTO implements IMovieDTO {
    adult?: boolean | null;
    backdropPath?: string | null;
    belongsToCollection?: any | null;
    budget?: number | null;
    genres?: GenreDTO[] | null;
    homepage?: string | null;
    id?: number | null;
    imdbId?: string | null;
    originalLanguage?: string | null;
    originalTitle?: string | null;
    overview?: string | null;
    popularity?: number | null;
    posterPath?: string | null;
    productionCompanies?: ProductionCompanyDTO[] | null;
    productionCountries?: ProductionCountryDTO[] | null;
    releaseDate?: string | null;
    revenue?: number | null;
    runtime?: number | null;
    spokenLanguages?: SpokenLanguageDTO[] | null;
    status?: string | null;
    tagline?: string | null;
    title?: string | null;
    video?: boolean | null;
    voteAverage?: number | null;
    voteCount?: number | null;

    constructor(data?: IMovieDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adult = _data["adult"] !== undefined ? _data["adult"] : <any>null;
            this.backdropPath = _data["backdropPath"] !== undefined ? _data["backdropPath"] : <any>null;
            this.belongsToCollection = _data["belongsToCollection"] !== undefined ? _data["belongsToCollection"] : <any>null;
            this.budget = _data["budget"] !== undefined ? _data["budget"] : <any>null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreDTO.fromJS(item));
            }
            else {
                this.genres = <any>null;
            }
            this.homepage = _data["homepage"] !== undefined ? _data["homepage"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.imdbId = _data["imdbId"] !== undefined ? _data["imdbId"] : <any>null;
            this.originalLanguage = _data["originalLanguage"] !== undefined ? _data["originalLanguage"] : <any>null;
            this.originalTitle = _data["originalTitle"] !== undefined ? _data["originalTitle"] : <any>null;
            this.overview = _data["overview"] !== undefined ? _data["overview"] : <any>null;
            this.popularity = _data["popularity"] !== undefined ? _data["popularity"] : <any>null;
            this.posterPath = _data["posterPath"] !== undefined ? _data["posterPath"] : <any>null;
            if (Array.isArray(_data["productionCompanies"])) {
                this.productionCompanies = [] as any;
                for (let item of _data["productionCompanies"])
                    this.productionCompanies!.push(ProductionCompanyDTO.fromJS(item));
            }
            else {
                this.productionCompanies = <any>null;
            }
            if (Array.isArray(_data["productionCountries"])) {
                this.productionCountries = [] as any;
                for (let item of _data["productionCountries"])
                    this.productionCountries!.push(ProductionCountryDTO.fromJS(item));
            }
            else {
                this.productionCountries = <any>null;
            }
            this.releaseDate = _data["releaseDate"] !== undefined ? _data["releaseDate"] : <any>null;
            this.revenue = _data["revenue"] !== undefined ? _data["revenue"] : <any>null;
            this.runtime = _data["runtime"] !== undefined ? _data["runtime"] : <any>null;
            if (Array.isArray(_data["spokenLanguages"])) {
                this.spokenLanguages = [] as any;
                for (let item of _data["spokenLanguages"])
                    this.spokenLanguages!.push(SpokenLanguageDTO.fromJS(item));
            }
            else {
                this.spokenLanguages = <any>null;
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.tagline = _data["tagline"] !== undefined ? _data["tagline"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.video = _data["video"] !== undefined ? _data["video"] : <any>null;
            this.voteAverage = _data["voteAverage"] !== undefined ? _data["voteAverage"] : <any>null;
            this.voteCount = _data["voteCount"] !== undefined ? _data["voteCount"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adult"] = this.adult !== undefined ? this.adult : <any>null;
        data["backdropPath"] = this.backdropPath !== undefined ? this.backdropPath : <any>null;
        data["belongsToCollection"] = this.belongsToCollection !== undefined ? this.belongsToCollection : <any>null;
        data["budget"] = this.budget !== undefined ? this.budget : <any>null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["homepage"] = this.homepage !== undefined ? this.homepage : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["imdbId"] = this.imdbId !== undefined ? this.imdbId : <any>null;
        data["originalLanguage"] = this.originalLanguage !== undefined ? this.originalLanguage : <any>null;
        data["originalTitle"] = this.originalTitle !== undefined ? this.originalTitle : <any>null;
        data["overview"] = this.overview !== undefined ? this.overview : <any>null;
        data["popularity"] = this.popularity !== undefined ? this.popularity : <any>null;
        data["posterPath"] = this.posterPath !== undefined ? this.posterPath : <any>null;
        if (Array.isArray(this.productionCompanies)) {
            data["productionCompanies"] = [];
            for (let item of this.productionCompanies)
                data["productionCompanies"].push(item.toJSON());
        }
        if (Array.isArray(this.productionCountries)) {
            data["productionCountries"] = [];
            for (let item of this.productionCountries)
                data["productionCountries"].push(item.toJSON());
        }
        data["releaseDate"] = this.releaseDate !== undefined ? this.releaseDate : <any>null;
        data["revenue"] = this.revenue !== undefined ? this.revenue : <any>null;
        data["runtime"] = this.runtime !== undefined ? this.runtime : <any>null;
        if (Array.isArray(this.spokenLanguages)) {
            data["spokenLanguages"] = [];
            for (let item of this.spokenLanguages)
                data["spokenLanguages"].push(item.toJSON());
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["tagline"] = this.tagline !== undefined ? this.tagline : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["video"] = this.video !== undefined ? this.video : <any>null;
        data["voteAverage"] = this.voteAverage !== undefined ? this.voteAverage : <any>null;
        data["voteCount"] = this.voteCount !== undefined ? this.voteCount : <any>null;
        return data;
    }
}

export interface IMovieDTO {
    adult?: boolean | null;
    backdropPath?: string | null;
    belongsToCollection?: any | null;
    budget?: number | null;
    genres?: GenreDTO[] | null;
    homepage?: string | null;
    id?: number | null;
    imdbId?: string | null;
    originalLanguage?: string | null;
    originalTitle?: string | null;
    overview?: string | null;
    popularity?: number | null;
    posterPath?: string | null;
    productionCompanies?: ProductionCompanyDTO[] | null;
    productionCountries?: ProductionCountryDTO[] | null;
    releaseDate?: string | null;
    revenue?: number | null;
    runtime?: number | null;
    spokenLanguages?: SpokenLanguageDTO[] | null;
    status?: string | null;
    tagline?: string | null;
    title?: string | null;
    video?: boolean | null;
    voteAverage?: number | null;
    voteCount?: number | null;
}

export class MovieDTOBaseResponseDTO implements IMovieDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: MovieDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IMovieDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(MovieDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): MovieDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IMovieDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: MovieDTO[] | null;
    errors?: string[] | null;
}

export class ObjectBaseResponseDTO implements IObjectBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: any[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IObjectBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(item);
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ObjectBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IObjectBaseResponseDTO {
    isSuccess?: boolean;
    content?: any[] | null;
    errors?: string[] | null;
}

export class Operation implements IOperation {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    operationTypeId?: number;
    coins?: number;
    person?: Person;
    operationType?: OperationType;

    constructor(data?: IOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.operationTypeId = _data["operationTypeId"] !== undefined ? _data["operationTypeId"] : <any>null;
            this.coins = _data["coins"] !== undefined ? _data["coins"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.operationType = _data["operationType"] ? OperationType.fromJS(_data["operationType"]) : <any>null;
        }
    }

    static fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["operationTypeId"] = this.operationTypeId !== undefined ? this.operationTypeId : <any>null;
        data["coins"] = this.coins !== undefined ? this.coins : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["operationType"] = this.operationType ? this.operationType.toJSON() : <any>null;
        return data;
    }
}

export interface IOperation {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    operationTypeId?: number;
    coins?: number;
    person?: Person;
    operationType?: OperationType;
}

export class OperationType implements IOperationType {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    type?: string | null;
    credit?: boolean;
    operations?: Operation[] | null;

    constructor(data?: IOperationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(Operation.fromJS(item));
            }
            else {
                this.operations = <any>null;
            }
        }
    }

    static fromJS(data: any): OperationType {
        data = typeof data === 'object' ? data : {};
        let result = new OperationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOperationType {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    type?: string | null;
    credit?: boolean;
    operations?: Operation[] | null;
}

export class Person implements IPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    imageURL?: string | null;
    birthDate?: Date;
    userId?: number;
    genderId?: number;
    balance?: number;
    user?: ApplicationUser;
    gender?: Gender;
    children?: PersonChild[] | null;
    reviews?: Review[] | null;
    comments?: Comment[] | null;
    premiumPerson?: PremiumPerson[] | null;
    awardsGiven?: AwardPerson[] | null;
    operations?: Operation[] | null;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.imageURL = _data["imageURL"] !== undefined ? _data["imageURL"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
            else {
                this.reviews = <any>null;
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            else {
                this.comments = <any>null;
            }
            if (Array.isArray(_data["premiumPerson"])) {
                this.premiumPerson = [] as any;
                for (let item of _data["premiumPerson"])
                    this.premiumPerson!.push(PremiumPerson.fromJS(item));
            }
            else {
                this.premiumPerson = <any>null;
            }
            if (Array.isArray(_data["awardsGiven"])) {
                this.awardsGiven = [] as any;
                for (let item of _data["awardsGiven"])
                    this.awardsGiven!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awardsGiven = <any>null;
            }
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(Operation.fromJS(item));
            }
            else {
                this.operations = <any>null;
            }
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["imageURL"] = this.imageURL !== undefined ? this.imageURL : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.premiumPerson)) {
            data["premiumPerson"] = [];
            for (let item of this.premiumPerson)
                data["premiumPerson"].push(item.toJSON());
        }
        if (Array.isArray(this.awardsGiven)) {
            data["awardsGiven"] = [];
            for (let item of this.awardsGiven)
                data["awardsGiven"].push(item.toJSON());
        }
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    imageURL?: string | null;
    birthDate?: Date;
    userId?: number;
    genderId?: number;
    balance?: number;
    user?: ApplicationUser;
    gender?: Gender;
    children?: PersonChild[] | null;
    reviews?: Review[] | null;
    comments?: Comment[] | null;
    premiumPerson?: PremiumPerson[] | null;
    awardsGiven?: AwardPerson[] | null;
    operations?: Operation[] | null;
}

export class PersonChild implements IPersonChild {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    genderId?: number;
    ageRangeId?: number;
    person?: Person;
    gender?: Gender;
    ageRange?: AgeRange;

    constructor(data?: IPersonChild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            this.ageRange = _data["ageRange"] ? AgeRange.fromJS(_data["ageRange"]) : <any>null;
        }
    }

    static fromJS(data: any): PersonChild {
        data = typeof data === 'object' ? data : {};
        let result = new PersonChild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        data["ageRange"] = this.ageRange ? this.ageRange.toJSON() : <any>null;
        return data;
    }
}

export interface IPersonChild {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    genderId?: number;
    ageRangeId?: number;
    person?: Person;
    gender?: Gender;
    ageRange?: AgeRange;
}

export class PersonOnCreateUserDTO implements IPersonOnCreateUserDTO {
    birthDate!: Date;
    genderId!: number;

    constructor(data?: IPersonOnCreateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): PersonOnCreateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOnCreateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface IPersonOnCreateUserDTO {
    birthDate: Date;
    genderId: number;
}

export class Platform implements IPlatform {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    url?: string | null;
    platformCategories?: PlatformCategory[] | null;

    constructor(data?: IPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            if (Array.isArray(_data["platformCategories"])) {
                this.platformCategories = [] as any;
                for (let item of _data["platformCategories"])
                    this.platformCategories!.push(PlatformCategory.fromJS(item));
            }
            else {
                this.platformCategories = <any>null;
            }
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        if (Array.isArray(this.platformCategories)) {
            data["platformCategories"] = [];
            for (let item of this.platformCategories)
                data["platformCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlatform {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    url?: string | null;
    platformCategories?: PlatformCategory[] | null;
}

export class PlatformCategory implements IPlatformCategory {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformId?: number;
    platform?: Platform;
    contents?: Content[] | null;

    constructor(data?: IPlatformCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
            this.platform = _data["platform"] ? Platform.fromJS(_data["platform"]) : <any>null;
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(Content.fromJS(item));
            }
            else {
                this.contents = <any>null;
            }
        }
    }

    static fromJS(data: any): PlatformCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        data["platform"] = this.platform ? this.platform.toJSON() : <any>null;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlatformCategory {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformId?: number;
    platform?: Platform;
    contents?: Content[] | null;
}

export class PremiumPerson implements IPremiumPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    tierPlanId?: number;
    startDate?: Date;
    endDate?: Date | null;
    autoRenewal?: boolean;
    person?: Person;
    tierPlan?: TierPlan;

    constructor(data?: IPremiumPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.tierPlanId = _data["tierPlanId"] !== undefined ? _data["tierPlanId"] : <any>null;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
            this.autoRenewal = _data["autoRenewal"] !== undefined ? _data["autoRenewal"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.tierPlan = _data["tierPlan"] ? TierPlan.fromJS(_data["tierPlan"]) : <any>null;
        }
    }

    static fromJS(data: any): PremiumPerson {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["tierPlanId"] = this.tierPlanId !== undefined ? this.tierPlanId : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["autoRenewal"] = this.autoRenewal !== undefined ? this.autoRenewal : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["tierPlan"] = this.tierPlan ? this.tierPlan.toJSON() : <any>null;
        return data;
    }
}

export interface IPremiumPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    tierPlanId?: number;
    startDate?: Date;
    endDate?: Date | null;
    autoRenewal?: boolean;
    person?: Person;
    tierPlan?: TierPlan;
}

export class ProductionCompanyDTO implements IProductionCompanyDTO {
    id?: number | null;
    logoPath?: string | null;
    name?: string | null;
    originCountry?: string | null;

    constructor(data?: IProductionCompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.logoPath = _data["logoPath"] !== undefined ? _data["logoPath"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.originCountry = _data["originCountry"] !== undefined ? _data["originCountry"] : <any>null;
        }
    }

    static fromJS(data: any): ProductionCompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductionCompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["logoPath"] = this.logoPath !== undefined ? this.logoPath : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["originCountry"] = this.originCountry !== undefined ? this.originCountry : <any>null;
        return data;
    }
}

export interface IProductionCompanyDTO {
    id?: number | null;
    logoPath?: string | null;
    name?: string | null;
    originCountry?: string | null;
}

export class ProductionCountryDTO implements IProductionCountryDTO {
    iso31661?: string | null;
    name?: string | null;

    constructor(data?: IProductionCountryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iso31661 = _data["iso31661"] !== undefined ? _data["iso31661"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProductionCountryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductionCountryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iso31661"] = this.iso31661 !== undefined ? this.iso31661 : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IProductionCountryDTO {
    iso31661?: string | null;
    name?: string | null;
}

export class ReadContentDTO implements IReadContentDTO {
    id?: number;
    name?: string | null;
    imageUrl?: string | null;
    platformCategory?: number;

    constructor(data?: IReadContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.platformCategory = _data["platformCategory"] !== undefined ? _data["platformCategory"] : <any>null;
        }
    }

    static fromJS(data: any): ReadContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["platformCategory"] = this.platformCategory !== undefined ? this.platformCategory : <any>null;
        return data;
    }
}

export interface IReadContentDTO {
    id?: number;
    name?: string | null;
    imageUrl?: string | null;
    platformCategory?: number;
}

export class ReadPersonDTO implements IReadPersonDTO {
    id?: number;
    userId?: number;
    imageURL?: string | null;
    birthDate?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    genderId?: number;

    constructor(data?: IReadPersonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.imageURL = _data["imageURL"] !== undefined ? _data["imageURL"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): ReadPersonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPersonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["imageURL"] = this.imageURL !== undefined ? this.imageURL : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface IReadPersonDTO {
    id?: number;
    userId?: number;
    imageURL?: string | null;
    birthDate?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    genderId?: number;
}

export class ReadUserDTO implements IReadUserDTO {
    id?: number;
    firstName?: string | null;
    lastName?: string | null;
    userName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnabled?: boolean;
    lockoutEnd?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    isConfirmEmailTokenSent?: boolean;
    associatedWithPerson?: ReadPersonDTO;

    constructor(data?: IReadUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = _data["twoFactorEnabled"] !== undefined ? _data["twoFactorEnabled"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.isConfirmEmailTokenSent = _data["isConfirmEmailTokenSent"] !== undefined ? _data["isConfirmEmailTokenSent"] : <any>null;
            this.associatedWithPerson = _data["associatedWithPerson"] ? ReadPersonDTO.fromJS(_data["associatedWithPerson"]) : <any>null;
        }
    }

    static fromJS(data: any): ReadUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["isConfirmEmailTokenSent"] = this.isConfirmEmailTokenSent !== undefined ? this.isConfirmEmailTokenSent : <any>null;
        data["associatedWithPerson"] = this.associatedWithPerson ? this.associatedWithPerson.toJSON() : <any>null;
        return data;
    }
}

export interface IReadUserDTO {
    id?: number;
    firstName?: string | null;
    lastName?: string | null;
    userName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnabled?: boolean;
    lockoutEnd?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    isConfirmEmailTokenSent?: boolean;
    associatedWithPerson?: ReadPersonDTO;
}

export class ReadUserDTOBaseResponseDTO implements IReadUserDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReadUserDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IReadUserDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReadUserDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReadUserDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadUserDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReadUserDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReadUserDTO[] | null;
    errors?: string[] | null;
}

export class RemoveUserFromRoleDTO implements IRemoveUserFromRoleDTO {
    roleName!: string;
    userName!: string;

    constructor(data?: IRemoveUserFromRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): RemoveUserFromRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUserFromRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IRemoveUserFromRoleDTO {
    roleName: string;
    userName: string;
}

export class RequestCheckEmailDTO implements IRequestCheckEmailDTO {
    email!: string;

    constructor(data?: IRequestCheckEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): RequestCheckEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCheckEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export interface IRequestCheckEmailDTO {
    email: string;
}

export class RequestCheckUserNameDTO implements IRequestCheckUserNameDTO {
    userName!: string;

    constructor(data?: IRequestCheckUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): RequestCheckUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCheckUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IRequestCheckUserNameDTO {
    userName: string;
}

export class RequestKeycodeDTO implements IRequestKeycodeDTO {
    email!: string;

    constructor(data?: IRequestKeycodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): RequestKeycodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKeycodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export interface IRequestKeycodeDTO {
    email: string;
}

export class ResetPasswordDTO implements IResetPasswordDTO {
    email!: string;
    password!: string;
    rePassword!: string;
    keyCode!: number;

    constructor(data?: IResetPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rePassword = _data["rePassword"] !== undefined ? _data["rePassword"] : <any>null;
            this.keyCode = _data["keyCode"] !== undefined ? _data["keyCode"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rePassword"] = this.rePassword !== undefined ? this.rePassword : <any>null;
        data["keyCode"] = this.keyCode !== undefined ? this.keyCode : <any>null;
        return data;
    }
}

export interface IResetPasswordDTO {
    email: string;
    password: string;
    rePassword: string;
    keyCode: number;
}

export class ResponseGenerateKeycodeDTO implements IResponseGenerateKeycodeDTO {
    isKeycodeSent?: boolean;

    constructor(data?: IResponseGenerateKeycodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isKeycodeSent = _data["isKeycodeSent"] !== undefined ? _data["isKeycodeSent"] : <any>null;
        }
    }

    static fromJS(data: any): ResponseGenerateKeycodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseGenerateKeycodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isKeycodeSent"] = this.isKeycodeSent !== undefined ? this.isKeycodeSent : <any>null;
        return data;
    }
}

export interface IResponseGenerateKeycodeDTO {
    isKeycodeSent?: boolean;
}

export class ResponseGenerateKeycodeDTOBaseResponseDTO implements IResponseGenerateKeycodeDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ResponseGenerateKeycodeDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IResponseGenerateKeycodeDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ResponseGenerateKeycodeDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ResponseGenerateKeycodeDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseGenerateKeycodeDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResponseGenerateKeycodeDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ResponseGenerateKeycodeDTO[] | null;
    errors?: string[] | null;
}

export class Review implements IReview {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    contentId?: number;
    person?: Person;
    content?: Content;
    reviewDetails?: ReviewDetails[] | null;
    comments?: Comment[] | null;
    awards?: AwardPerson[] | null;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.content = _data["content"] ? Content.fromJS(_data["content"]) : <any>null;
            if (Array.isArray(_data["reviewDetails"])) {
                this.reviewDetails = [] as any;
                for (let item of _data["reviewDetails"])
                    this.reviewDetails!.push(ReviewDetails.fromJS(item));
            }
            else {
                this.reviewDetails = <any>null;
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            else {
                this.comments = <any>null;
            }
            if (Array.isArray(_data["awards"])) {
                this.awards = [] as any;
                for (let item of _data["awards"])
                    this.awards!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awards = <any>null;
            }
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        if (Array.isArray(this.reviewDetails)) {
            data["reviewDetails"] = [];
            for (let item of this.reviewDetails)
                data["reviewDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReview {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    contentId?: number;
    person?: Person;
    content?: Content;
    reviewDetails?: ReviewDetails[] | null;
    comments?: Comment[] | null;
    awards?: AwardPerson[] | null;
}

export class ReviewDetails implements IReviewDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    review?: Review;

    constructor(data?: IReviewDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
        }
    }

    static fromJS(data: any): ReviewDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        return data;
    }
}

export interface IReviewDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    review?: Review;
}

export class ReviewDetailsDto implements IReviewDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    content?: ReadContentDTO;
    goldenAwards?: number;
    silverAwards?: number;
    bronzeAwards?: number;
    commentsQuantity?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    createDate?: Date;
    edited?: boolean;

    constructor(data?: IReviewDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.person = _data["person"] ? ReadPersonDTO.fromJS(_data["person"]) : <any>null;
            this.content = _data["content"] ? ReadContentDTO.fromJS(_data["content"]) : <any>null;
            this.goldenAwards = _data["goldenAwards"] !== undefined ? _data["goldenAwards"] : <any>null;
            this.silverAwards = _data["silverAwards"] !== undefined ? _data["silverAwards"] : <any>null;
            this.bronzeAwards = _data["bronzeAwards"] !== undefined ? _data["bronzeAwards"] : <any>null;
            this.commentsQuantity = _data["commentsQuantity"] !== undefined ? _data["commentsQuantity"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.edited = _data["edited"] !== undefined ? _data["edited"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        data["goldenAwards"] = this.goldenAwards !== undefined ? this.goldenAwards : <any>null;
        data["silverAwards"] = this.silverAwards !== undefined ? this.silverAwards : <any>null;
        data["bronzeAwards"] = this.bronzeAwards !== undefined ? this.bronzeAwards : <any>null;
        data["commentsQuantity"] = this.commentsQuantity !== undefined ? this.commentsQuantity : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["edited"] = this.edited !== undefined ? this.edited : <any>null;
        return data;
    }
}

export interface IReviewDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    content?: ReadContentDTO;
    goldenAwards?: number;
    silverAwards?: number;
    bronzeAwards?: number;
    commentsQuantity?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    createDate?: Date;
    edited?: boolean;
}

export class ReviewDetailsDtoBaseResponseDTO implements IReviewDetailsDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReviewDetailsDto[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IReviewDetailsDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReviewDetailsDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReviewDetailsDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetailsDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReviewDetailsDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReviewDetailsDto[] | null;
    errors?: string[] | null;
}

export class SpokenLanguageDTO implements ISpokenLanguageDTO {
    englishName?: string | null;
    iso6391?: string | null;
    name?: string | null;

    constructor(data?: ISpokenLanguageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : <any>null;
            this.iso6391 = _data["iso6391"] !== undefined ? _data["iso6391"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SpokenLanguageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SpokenLanguageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["englishName"] = this.englishName !== undefined ? this.englishName : <any>null;
        data["iso6391"] = this.iso6391 !== undefined ? this.iso6391 : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ISpokenLanguageDTO {
    englishName?: string | null;
    iso6391?: string | null;
    name?: string | null;
}

export class StringBaseResponseDTO implements IStringBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: string[] | null;
    readonly errors?: string[] | null;

    constructor(data?: IStringBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(item);
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): StringBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IStringBaseResponseDTO {
    isSuccess?: boolean;
    content?: string[] | null;
    errors?: string[] | null;
}

export class Tier implements ITier {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isPremium?: boolean;
    tierPlans?: TierPlan[] | null;

    constructor(data?: ITier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isPremium = _data["isPremium"] !== undefined ? _data["isPremium"] : <any>null;
            if (Array.isArray(_data["tierPlans"])) {
                this.tierPlans = [] as any;
                for (let item of _data["tierPlans"])
                    this.tierPlans!.push(TierPlan.fromJS(item));
            }
            else {
                this.tierPlans = <any>null;
            }
        }
    }

    static fromJS(data: any): Tier {
        data = typeof data === 'object' ? data : {};
        let result = new Tier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isPremium"] = this.isPremium !== undefined ? this.isPremium : <any>null;
        if (Array.isArray(this.tierPlans)) {
            data["tierPlans"] = [];
            for (let item of this.tierPlans)
                data["tierPlans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITier {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isPremium?: boolean;
    tierPlans?: TierPlan[] | null;
}

export class TierPlan implements ITierPlan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    tierId?: number;
    timespanId?: number;
    price?: number;
    tier?: Tier;
    timespan?: Timespan;
    premiumPerson?: PremiumPerson[] | null;

    constructor(data?: ITierPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.tierId = _data["tierId"] !== undefined ? _data["tierId"] : <any>null;
            this.timespanId = _data["timespanId"] !== undefined ? _data["timespanId"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.tier = _data["tier"] ? Tier.fromJS(_data["tier"]) : <any>null;
            this.timespan = _data["timespan"] ? Timespan.fromJS(_data["timespan"]) : <any>null;
            if (Array.isArray(_data["premiumPerson"])) {
                this.premiumPerson = [] as any;
                for (let item of _data["premiumPerson"])
                    this.premiumPerson!.push(PremiumPerson.fromJS(item));
            }
            else {
                this.premiumPerson = <any>null;
            }
        }
    }

    static fromJS(data: any): TierPlan {
        data = typeof data === 'object' ? data : {};
        let result = new TierPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["tierId"] = this.tierId !== undefined ? this.tierId : <any>null;
        data["timespanId"] = this.timespanId !== undefined ? this.timespanId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["tier"] = this.tier ? this.tier.toJSON() : <any>null;
        data["timespan"] = this.timespan ? this.timespan.toJSON() : <any>null;
        if (Array.isArray(this.premiumPerson)) {
            data["premiumPerson"] = [];
            for (let item of this.premiumPerson)
                data["premiumPerson"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITierPlan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    tierId?: number;
    timespanId?: number;
    price?: number;
    tier?: Tier;
    timespan?: Timespan;
    premiumPerson?: PremiumPerson[] | null;
}

export class Timespan implements ITimespan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    days?: number;
    tierPlans?: TierPlan[] | null;

    constructor(data?: ITimespan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.days = _data["days"] !== undefined ? _data["days"] : <any>null;
            if (Array.isArray(_data["tierPlans"])) {
                this.tierPlans = [] as any;
                for (let item of _data["tierPlans"])
                    this.tierPlans!.push(TierPlan.fromJS(item));
            }
            else {
                this.tierPlans = <any>null;
            }
        }
    }

    static fromJS(data: any): Timespan {
        data = typeof data === 'object' ? data : {};
        let result = new Timespan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["days"] = this.days !== undefined ? this.days : <any>null;
        if (Array.isArray(this.tierPlans)) {
            data["tierPlans"] = [];
            for (let item of this.tierPlans)
                data["tierPlans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITimespan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    days?: number;
    tierPlans?: TierPlan[] | null;
}

export class TokenDTO implements ITokenDTO {
    accessToken?: string | null;
    refreshToken?: string | null;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;

    constructor(data?: ITokenDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
            this.accessTokenExpiration = _data["accessTokenExpiration"] ? new Date(_data["accessTokenExpiration"].toString()) : <any>null;
            this.refreshTokenExpiration = _data["refreshTokenExpiration"] ? new Date(_data["refreshTokenExpiration"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TokenDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        data["accessTokenExpiration"] = this.accessTokenExpiration ? this.accessTokenExpiration.toISOString() : <any>null;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration ? this.refreshTokenExpiration.toISOString() : <any>null;
        return data;
    }
}

export interface ITokenDTO {
    accessToken?: string | null;
    refreshToken?: string | null;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;
}

export class TokenDTOBaseResponseDTO implements ITokenDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: TokenDTO[] | null;
    readonly errors?: string[] | null;

    constructor(data?: ITokenDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(TokenDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): TokenDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ITokenDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: TokenDTO[] | null;
    errors?: string[] | null;
}

export class UpdateUserDTO implements IUpdateUserDTO {
    userName?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    personDetails!: PersonOnCreateUserDTO;

    constructor(data?: IUpdateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personDetails = new PersonOnCreateUserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.personDetails = _data["personDetails"] ? PersonOnCreateUserDTO.fromJS(_data["personDetails"]) : new PersonOnCreateUserDTO();
        }
    }

    static fromJS(data: any): UpdateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["personDetails"] = this.personDetails ? this.personDetails.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateUserDTO {
    userName?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    personDetails: PersonOnCreateUserDTO;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}