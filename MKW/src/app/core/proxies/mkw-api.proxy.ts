//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    accountGet(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processAccountGet(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    active(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    id(id: number): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    token(): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/user/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processToken(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    usernameGet(userName: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsernameGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsernameGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processUsernameGet(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    usernameDelete(userName: string): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsernameDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsernameDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUsernameDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    role(role: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/role/{role}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    claim(issuer: string, originalIssuer: string, properties: { [key: string]: string; }, subject_AuthenticationType: string, subject_IsAuthenticated: boolean, subject_Actor_AuthenticationType: string, subject_Actor_IsAuthenticated: boolean, subject_Actor_Actor: ClaimsIdentity, subject_Actor_BootstrapContext: any, subject_Actor_Claims: Claim[], subject_Actor_Label: string, subject_Actor_Name: string, subject_Actor_NameClaimType: string, subject_Actor_RoleClaimType: string, subject_BootstrapContext: any, subject_Claims: Claim[], subject_Label: string, subject_Name: string, subject_NameClaimType: string, subject_RoleClaimType: string, type: string, value: string, valueType: string, claim: string): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/claim/{claim}";
        if (issuer === undefined || issuer === null)
            throw new Error("The parameter 'issuer' must be defined.");
        url_ = url_.replace("{Issuer}", encodeURIComponent("" + issuer));
        if (originalIssuer === undefined || originalIssuer === null)
            throw new Error("The parameter 'originalIssuer' must be defined.");
        url_ = url_.replace("{OriginalIssuer}", encodeURIComponent("" + originalIssuer));
        if (properties === undefined || properties === null)
            throw new Error("The parameter 'properties' must be defined.");
        url_ = url_.replace("{Properties}", encodeURIComponent("" + properties));
        if (subject_AuthenticationType === undefined || subject_AuthenticationType === null)
            throw new Error("The parameter 'subject_AuthenticationType' must be defined.");
        url_ = url_.replace("{Subject.AuthenticationType}", encodeURIComponent("" + subject_AuthenticationType));
        if (subject_IsAuthenticated === undefined || subject_IsAuthenticated === null)
            throw new Error("The parameter 'subject_IsAuthenticated' must be defined.");
        url_ = url_.replace("{Subject.IsAuthenticated}", encodeURIComponent("" + subject_IsAuthenticated));
        if (subject_Actor_AuthenticationType === undefined || subject_Actor_AuthenticationType === null)
            throw new Error("The parameter 'subject_Actor_AuthenticationType' must be defined.");
        url_ = url_.replace("{Subject.Actor.AuthenticationType}", encodeURIComponent("" + subject_Actor_AuthenticationType));
        if (subject_Actor_IsAuthenticated === undefined || subject_Actor_IsAuthenticated === null)
            throw new Error("The parameter 'subject_Actor_IsAuthenticated' must be defined.");
        url_ = url_.replace("{Subject.Actor.IsAuthenticated}", encodeURIComponent("" + subject_Actor_IsAuthenticated));
        if (subject_Actor_Actor === undefined || subject_Actor_Actor === null)
            throw new Error("The parameter 'subject_Actor_Actor' must be defined.");
        url_ = url_.replace("{Subject.Actor.Actor}", encodeURIComponent("" + subject_Actor_Actor));
        if (subject_Actor_BootstrapContext === undefined || subject_Actor_BootstrapContext === null)
            throw new Error("The parameter 'subject_Actor_BootstrapContext' must be defined.");
        url_ = url_.replace("{Subject.Actor.BootstrapContext}", encodeURIComponent("" + subject_Actor_BootstrapContext));
        if (subject_Actor_Claims === undefined || subject_Actor_Claims === null)
            throw new Error("The parameter 'subject_Actor_Claims' must be defined.");
        url_ = url_.replace("{Subject.Actor.Claims}", encodeURIComponent(subject_Actor_Claims.join()));
        if (subject_Actor_Label === undefined || subject_Actor_Label === null)
            throw new Error("The parameter 'subject_Actor_Label' must be defined.");
        url_ = url_.replace("{Subject.Actor.Label}", encodeURIComponent("" + subject_Actor_Label));
        if (subject_Actor_Name === undefined || subject_Actor_Name === null)
            throw new Error("The parameter 'subject_Actor_Name' must be defined.");
        url_ = url_.replace("{Subject.Actor.Name}", encodeURIComponent("" + subject_Actor_Name));
        if (subject_Actor_NameClaimType === undefined || subject_Actor_NameClaimType === null)
            throw new Error("The parameter 'subject_Actor_NameClaimType' must be defined.");
        url_ = url_.replace("{Subject.Actor.NameClaimType}", encodeURIComponent("" + subject_Actor_NameClaimType));
        if (subject_Actor_RoleClaimType === undefined || subject_Actor_RoleClaimType === null)
            throw new Error("The parameter 'subject_Actor_RoleClaimType' must be defined.");
        url_ = url_.replace("{Subject.Actor.RoleClaimType}", encodeURIComponent("" + subject_Actor_RoleClaimType));
        if (subject_BootstrapContext === undefined || subject_BootstrapContext === null)
            throw new Error("The parameter 'subject_BootstrapContext' must be defined.");
        url_ = url_.replace("{Subject.BootstrapContext}", encodeURIComponent("" + subject_BootstrapContext));
        if (subject_Claims === undefined || subject_Claims === null)
            throw new Error("The parameter 'subject_Claims' must be defined.");
        url_ = url_.replace("{Subject.Claims}", encodeURIComponent(subject_Claims.join()));
        if (subject_Label === undefined || subject_Label === null)
            throw new Error("The parameter 'subject_Label' must be defined.");
        url_ = url_.replace("{Subject.Label}", encodeURIComponent("" + subject_Label));
        if (subject_Name === undefined || subject_Name === null)
            throw new Error("The parameter 'subject_Name' must be defined.");
        url_ = url_.replace("{Subject.Name}", encodeURIComponent("" + subject_Name));
        if (subject_NameClaimType === undefined || subject_NameClaimType === null)
            throw new Error("The parameter 'subject_NameClaimType' must be defined.");
        url_ = url_.replace("{Subject.NameClaimType}", encodeURIComponent("" + subject_NameClaimType));
        if (subject_RoleClaimType === undefined || subject_RoleClaimType === null)
            throw new Error("The parameter 'subject_RoleClaimType' must be defined.");
        url_ = url_.replace("{Subject.RoleClaimType}", encodeURIComponent("" + subject_RoleClaimType));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{Type}", encodeURIComponent("" + type));
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined.");
        url_ = url_.replace("{Value}", encodeURIComponent("" + value));
        if (valueType === undefined || valueType === null)
            throw new Error("The parameter 'valueType' must be defined.");
        url_ = url_.replace("{ValueType}", encodeURIComponent("" + valueType));
        if (claim === undefined || claim === null)
            throw new Error("The parameter 'claim' must be defined.");
        url_ = url_.replace("{claim}", encodeURIComponent("" + claim));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processClaim(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkEmail(body: RequestCheckEmailDTO | undefined): Observable<CheckEmailDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register/checkEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckEmailDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckEmailDTOBaseResponseDTO>;
        }));
    }

    protected processCheckEmail(response: HttpResponseBase): Observable<CheckEmailDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckEmailDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkUsername(body: RequestCheckUserNameDTO | undefined): Observable<CheckUserNameDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register/checkUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckUserNameDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckUserNameDTOBaseResponseDTO>;
        }));
    }

    protected processCheckUsername(response: HttpResponseBase): Observable<CheckUserNameDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckUserNameDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @param body (optional) 
     * @return Created
     */
    register(language: string | undefined, body: CreateUserDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/register?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ReadUserDTOBaseResponseDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @param body (optional) 
     * @return No Content
     */
    update(language: string | undefined, body: UpdateUserDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/user/update?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = ObjectBaseResponseDTO.fromJS(resultData204);
            return _observableOf(result204);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @param body (optional) 
     * @return Success
     */
    passwordKeycode(language: string | undefined, body: RequestKeycodeDTO | undefined): Observable<ResponseGenerateKeycodeDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/password-keycode?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordKeycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordKeycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseGenerateKeycodeDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseGenerateKeycodeDTOBaseResponseDTO>;
        }));
    }

    protected processPasswordKeycode(response: HttpResponseBase): Observable<ResponseGenerateKeycodeDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseGenerateKeycodeDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @param body (optional) 
     * @return Success
     */
    emailKeycode(language: string | undefined, body: RequestKeycodeDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/email-keycode?";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailKeycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailKeycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processEmailKeycode(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmEmail(body: ConfirmAccountEmailDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/email/confirmEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reset(body: ResetPasswordDTO | undefined): Observable<ReadUserDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/password/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadUserDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadUserDTOBaseResponseDTO>;
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<ReadUserDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadUserDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    accountDelete(id: number): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processAccountDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AgeRangeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    ageRange(): Observable<AgeRangeDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/AgeRange";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgeRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgeRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgeRangeDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgeRangeDtoBaseResponseDTO>;
        }));
    }

    protected processAgeRange(response: HttpResponseBase): Observable<AgeRangeDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgeRangeDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AlgorithmClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param page (optional) 
     * @param count (optional) 
     * @param language (optional) 
     * @return Success
     */
    algorithm(page: number | undefined, count: number | undefined, language: string | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Algorithm?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAlgorithm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAlgorithm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processAlgorithm(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    username(body: LoginRequestByUserNameDTO | undefined): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/username";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processUsername(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    email(body: LoginRequestByEmailDTO | undefined): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processEmail(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    refresh(): Observable<TokenDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authentication/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDTOBaseResponseDTO>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<TokenDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthorizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    role(): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processRole(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userPost(body: AddUserToRoleDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUserPost(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userDelete(body: RemoveUserFromRoleDTO | undefined): Observable<ObjectBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Authorization/role/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectBaseResponseDTO>;
        }));
    }

    protected processUserDelete(response: HttpResponseBase): Observable<ObjectBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AwardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    awardGet(): Observable<AwardDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Award";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwardDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwardDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processAwardGet(response: HttpResponseBase): Observable<AwardDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwardDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    awardPost(body: GiveAwardDto | undefined): Observable<GivenAwardDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Award";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAwardPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAwardPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GivenAwardDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GivenAwardDtoBaseResponseDTO>;
        }));
    }

    protected processAwardPost(response: HttpResponseBase): Observable<GivenAwardDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GivenAwardDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChildClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    id(id: number): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    childGet(): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildGet(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    childPost(body: CreateChildDto | undefined): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildPost(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    childPut(body: ChildDto | undefined): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildPut(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    childDelete(id: number): Observable<ChildDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Child/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChildDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChildDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChildDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChildDtoBaseResponseDTO>;
        }));
    }

    protected processChildDelete(response: HttpResponseBase): Observable<ChildDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChildDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    commentGet(id: number, language: string | undefined): Observable<CommentDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Comment/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processCommentGet(response: HttpResponseBase): Observable<CommentDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    commentDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/Comment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCommentDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    review(reviewId: number, language: string | undefined): Observable<CommentDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Comment/Review/{reviewId}?";
        if (reviewId === undefined || reviewId === null)
            throw new Error("The parameter 'reviewId' must be defined.");
        url_ = url_.replace("{reviewId}", encodeURIComponent("" + reviewId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReview(response: HttpResponseBase): Observable<CommentDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentPost(body: CreateCommentDto | undefined): Observable<CommentDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Comment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processCommentPost(response: HttpResponseBase): Observable<CommentDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentPut(body: UpdateCommentDto | undefined): Observable<CommentDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Comment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCommentPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCommentPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processCommentPut(response: HttpResponseBase): Observable<CommentDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    answer(body: AnswerCommentDto | undefined): Observable<CommentDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Comment/Answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processAnswer(response: HttpResponseBase): Observable<CommentDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    id(contentId: number, language: string | undefined): Observable<ContentDetailsDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Content/id/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetailsDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetailsDTOBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ContentDetailsDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetailsDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    external(externalContentId: string, platformId: PlatformEnum, language: string | undefined): Observable<ContentDetailsDTO> {
        let url_ = this.baseUrl + "/v1/Content/external/{platformId}/{externalContentId}?";
        if (externalContentId === undefined || externalContentId === null)
            throw new Error("The parameter 'externalContentId' must be defined.");
        url_ = url_.replace("{externalContentId}", encodeURIComponent("" + externalContentId));
        if (platformId === undefined || platformId === null)
            throw new Error("The parameter 'platformId' must be defined.");
        url_ = url_.replace("{platformId}", encodeURIComponent("" + platformId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetailsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetailsDTO>;
        }));
    }

    protected processExternal(response: HttpResponseBase): Observable<ContentDetailsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetailsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param platformId (optional) 
     * @param language (optional) 
     * @return Success
     */
    content(query: string, platformId: PlatformEnum | undefined, language: string | undefined): Observable<ContentListItemDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Content?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (platformId === null)
            throw new Error("The parameter 'platformId' cannot be null.");
        else if (platformId !== undefined)
            url_ += "platformId=" + encodeURIComponent("" + platformId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentListItemDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentListItemDTOBaseResponseDTO>;
        }));
    }

    protected processContent(response: HttpResponseBase): Observable<ContentListItemDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentListItemDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GenderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    gender(): Observable<GenderDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Gender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGender(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenderDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenderDtoBaseResponseDTO>;
        }));
    }

    protected processGender(response: HttpResponseBase): Observable<GenderDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenderDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = StringBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = StringBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MovieClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    id(movieId: number, language: string | undefined): Observable<MovieDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Movie/id/{movieId}?";
        if (movieId === undefined || movieId === null)
            throw new Error("The parameter 'movieId' must be defined.");
        url_ = url_.replace("{movieId}", encodeURIComponent("" + movieId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDTOBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<MovieDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @return Success
     */
    movie(name: string | undefined, language: string | undefined): Observable<SearchDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Movie?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMovie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMovie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchDTOBaseResponseDTO>;
        }));
    }

    protected processMovie(response: HttpResponseBase): Observable<SearchDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PlatformClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    platform(): Observable<Platform[]> {
        let url_ = this.baseUrl + "/v1/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlatform(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Platform[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Platform[]>;
        }));
    }

    protected processPlatform(response: HttpResponseBase): Observable<Platform[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Platform.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProfileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    username(username: string): Observable<ReadProfileDTOBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Profile/username/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadProfileDTOBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadProfileDTOBaseResponseDTO>;
        }));
    }

    protected processUsername(response: HttpResponseBase): Observable<ReadProfileDTOBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadProfileDTOBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    search(username: string): Observable<ReadProfileDTOIEnumerableBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Profile/search/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadProfileDTOIEnumerableBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadProfileDTOIEnumerableBaseResponseDTO>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ReadProfileDTOIEnumerableBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadProfileDTOIEnumerableBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    reason(): Observable<ReportReasonDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Report/Reason";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReason(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportReasonDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportReasonDtoBaseResponseDTO>;
        }));
    }

    protected processReason(response: HttpResponseBase): Observable<ReportReasonDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportReasonDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    id(reasonId: number): Observable<ReportReasonDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Report/Reason/id/{reasonId}";
        if (reasonId === undefined || reasonId === null)
            throw new Error("The parameter 'reasonId' must be defined.");
        url_ = url_.replace("{reasonId}", encodeURIComponent("" + reasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportReasonDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportReasonDtoBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ReportReasonDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportReasonDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param reasonId (optional) 
     * @return Success
     */
    reportGet(page: number | undefined, pageSize: number | undefined, reasonId: number | undefined): Observable<ReportDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Report?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (reasonId === null)
            throw new Error("The parameter 'reasonId' cannot be null.");
        else if (reasonId !== undefined)
            url_ += "reasonId=" + encodeURIComponent("" + reasonId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportDtoBaseResponseDTO>;
        }));
    }

    protected processReportGet(response: HttpResponseBase): Observable<ReportDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reportPost(body: CreateReportDto | undefined): Observable<ReportDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportDtoBaseResponseDTO>;
        }));
    }

    protected processReportPost(response: HttpResponseBase): Observable<ReportDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reportPatch(body: UpdateReportStatusDto | undefined): Observable<ReportDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportPatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportDtoBaseResponseDTO>;
        }));
    }

    protected processReportPatch(response: HttpResponseBase): Observable<ReportDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    id(id: number, language: string | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review/id/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param language (optional) 
     * @return Success
     */
    user(userId: number, language: string | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processUser(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param childId (optional) 
     * @param page (optional) 
     * @param count (optional) 
     * @param language (optional) 
     * @return Success
     */
    reviewGet(childId: number | undefined, page: number | undefined, count: number | undefined, language: string | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review?";
        if (childId === null)
            throw new Error("The parameter 'childId' cannot be null.");
        else if (childId !== undefined)
            url_ += "childId=" + encodeURIComponent("" + childId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReviewGet(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reviewPost(body: CreateReviewDto | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReviewPost(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reviewPut(body: UpdateReviewDto | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processReviewPut(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param count (optional) 
     * @param language (optional) 
     * @return Success
     */
    trending(page: number | undefined, count: number | undefined, language: string | undefined): Observable<ReviewDetailsDtoBaseResponseDTO> {
        let url_ = this.baseUrl + "/v1/Review/Trending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrending(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDetailsDtoBaseResponseDTO>;
        }));
    }

    protected processTrending(response: HttpResponseBase): Observable<ReviewDetailsDtoBaseResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDetailsDtoBaseResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    reviewDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/Review/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReviewDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReviewDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ObjectBaseResponseDTO.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ObjectBaseResponseDTO.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AddUserToRoleDTO implements IAddUserToRoleDTO {
    roleName!: string;
    userName!: string;

    constructor(data?: IAddUserToRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): AddUserToRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IAddUserToRoleDTO {
    roleName: string;
    userName: string;
}

export class AgeRange implements IAgeRange {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    initialAge?: number;
    finalAge?: number;
    children?: PersonChild[] | null;

    constructor(data?: IAgeRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.initialAge = _data["initialAge"] !== undefined ? _data["initialAge"] : <any>null;
            this.finalAge = _data["finalAge"] !== undefined ? _data["finalAge"] : <any>null;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
        }
    }

    static fromJS(data: any): AgeRange {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["initialAge"] = this.initialAge !== undefined ? this.initialAge : <any>null;
        data["finalAge"] = this.finalAge !== undefined ? this.finalAge : <any>null;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgeRange {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    initialAge?: number;
    finalAge?: number;
    children?: PersonChild[] | null;
}

export class AgeRangeDto implements IAgeRangeDto {
    id?: number;
    initialAge?: number;
    finalAge?: number;

    constructor(data?: IAgeRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.initialAge = _data["initialAge"] !== undefined ? _data["initialAge"] : <any>null;
            this.finalAge = _data["finalAge"] !== undefined ? _data["finalAge"] : <any>null;
        }
    }

    static fromJS(data: any): AgeRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["initialAge"] = this.initialAge !== undefined ? this.initialAge : <any>null;
        data["finalAge"] = this.finalAge !== undefined ? this.finalAge : <any>null;
        return data;
    }
}

export interface IAgeRangeDto {
    id?: number;
    initialAge?: number;
    finalAge?: number;
}

export class AgeRangeDtoBaseResponseDTO implements IAgeRangeDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: AgeRangeDto[] | null;
    pagedContent?: AgeRangeDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IAgeRangeDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(AgeRangeDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? AgeRangeDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): AgeRangeDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRangeDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IAgeRangeDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: AgeRangeDto[] | null;
    pagedContent?: AgeRangeDtoPagedList;
    errors?: string[] | null;
}

export class AgeRangeDtoPagedList implements IAgeRangeDtoPagedList {
    results?: AgeRangeDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAgeRangeDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AgeRangeDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): AgeRangeDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new AgeRangeDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IAgeRangeDtoPagedList {
    results?: AgeRangeDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AnswerCommentDto implements IAnswerCommentDto {
    commentId?: number;
    text?: string | null;

    constructor(data?: IAnswerCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
        }
    }

    static fromJS(data: any): AnswerCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data;
    }
}

export interface IAnswerCommentDto {
    commentId?: number;
    text?: string | null;
}

export class ApplicationUser implements IApplicationUser {
    id?: number;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | null;
    lastName?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.normalizedUserName = _data["normalizedUserName"] !== undefined ? _data["normalizedUserName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.normalizedEmail = _data["normalizedEmail"] !== undefined ? _data["normalizedEmail"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.passwordHash = _data["passwordHash"] !== undefined ? _data["passwordHash"] : <any>null;
            this.securityStamp = _data["securityStamp"] !== undefined ? _data["securityStamp"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = _data["twoFactorEnabled"] !== undefined ? _data["twoFactorEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.accessFailedCount = _data["accessFailedCount"] !== undefined ? _data["accessFailedCount"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["normalizedUserName"] = this.normalizedUserName !== undefined ? this.normalizedUserName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["normalizedEmail"] = this.normalizedEmail !== undefined ? this.normalizedEmail : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["securityStamp"] = this.securityStamp !== undefined ? this.securityStamp : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["accessFailedCount"] = this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IApplicationUser {
    id?: number;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    firstName?: string | null;
    lastName?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
}

export class Award implements IAward {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    price?: number;
    value?: number;
    stripeId?: string | null;
    awardPerson?: AwardPerson[] | null;

    constructor(data?: IAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.stripeId = _data["stripeId"] !== undefined ? _data["stripeId"] : <any>null;
            if (Array.isArray(_data["awardPerson"])) {
                this.awardPerson = [] as any;
                for (let item of _data["awardPerson"])
                    this.awardPerson!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awardPerson = <any>null;
            }
        }
    }

    static fromJS(data: any): Award {
        data = typeof data === 'object' ? data : {};
        let result = new Award();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["stripeId"] = this.stripeId !== undefined ? this.stripeId : <any>null;
        if (Array.isArray(this.awardPerson)) {
            data["awardPerson"] = [];
            for (let item of this.awardPerson)
                data["awardPerson"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAward {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    price?: number;
    value?: number;
    stripeId?: string | null;
    awardPerson?: AwardPerson[] | null;
}

export class AwardDetailsDto implements IAwardDetailsDto {
    awardId?: number;
    name?: string | null;
    price?: number;
    stripeId?: string | null;

    constructor(data?: IAwardDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.awardId = _data["awardId"] !== undefined ? _data["awardId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.stripeId = _data["stripeId"] !== undefined ? _data["stripeId"] : <any>null;
        }
    }

    static fromJS(data: any): AwardDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardId"] = this.awardId !== undefined ? this.awardId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["stripeId"] = this.stripeId !== undefined ? this.stripeId : <any>null;
        return data;
    }
}

export interface IAwardDetailsDto {
    awardId?: number;
    name?: string | null;
    price?: number;
    stripeId?: string | null;
}

export class AwardDetailsDtoBaseResponseDTO implements IAwardDetailsDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: AwardDetailsDto[] | null;
    pagedContent?: AwardDetailsDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IAwardDetailsDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(AwardDetailsDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? AwardDetailsDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): AwardDetailsDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDetailsDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IAwardDetailsDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: AwardDetailsDto[] | null;
    pagedContent?: AwardDetailsDtoPagedList;
    errors?: string[] | null;
}

export class AwardDetailsDtoPagedList implements IAwardDetailsDtoPagedList {
    results?: AwardDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAwardDetailsDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AwardDetailsDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): AwardDetailsDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new AwardDetailsDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IAwardDetailsDtoPagedList {
    results?: AwardDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AwardPerson implements IAwardPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    awardId?: number;
    person?: Person;
    review?: Review;
    award?: Award;

    constructor(data?: IAwardPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.awardId = _data["awardId"] !== undefined ? _data["awardId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
            this.award = _data["award"] ? Award.fromJS(_data["award"]) : <any>null;
        }
    }

    static fromJS(data: any): AwardPerson {
        data = typeof data === 'object' ? data : {};
        let result = new AwardPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["awardId"] = this.awardId !== undefined ? this.awardId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["award"] = this.award ? this.award.toJSON() : <any>null;
        return data;
    }
}

export interface IAwardPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number;
    awardId?: number;
    person?: Person;
    review?: Review;
    award?: Award;
}

export class CheckEmailDTO implements ICheckEmailDTO {
    readonly isEmailValid?: boolean;

    constructor(data?: ICheckEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isEmailValid = _data["isEmailValid"] !== undefined ? _data["isEmailValid"] : <any>null;
        }
    }

    static fromJS(data: any): CheckEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailValid"] = this.isEmailValid !== undefined ? this.isEmailValid : <any>null;
        return data;
    }
}

export interface ICheckEmailDTO {
    isEmailValid?: boolean;
}

export class CheckEmailDTOBaseResponseDTO implements ICheckEmailDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: CheckEmailDTO[] | null;
    pagedContent?: CheckEmailDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: ICheckEmailDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CheckEmailDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? CheckEmailDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): CheckEmailDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ICheckEmailDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: CheckEmailDTO[] | null;
    pagedContent?: CheckEmailDTOPagedList;
    errors?: string[] | null;
}

export class CheckEmailDTOPagedList implements ICheckEmailDTOPagedList {
    results?: CheckEmailDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ICheckEmailDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CheckEmailDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): CheckEmailDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ICheckEmailDTOPagedList {
    results?: CheckEmailDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CheckUserNameDTO implements ICheckUserNameDTO {
    isUserNameValid?: boolean;

    constructor(data?: ICheckUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameValid = _data["isUserNameValid"] !== undefined ? _data["isUserNameValid"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameValid"] = this.isUserNameValid !== undefined ? this.isUserNameValid : <any>null;
        return data;
    }
}

export interface ICheckUserNameDTO {
    isUserNameValid?: boolean;
}

export class CheckUserNameDTOBaseResponseDTO implements ICheckUserNameDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: CheckUserNameDTO[] | null;
    pagedContent?: CheckUserNameDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: ICheckUserNameDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CheckUserNameDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? CheckUserNameDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): CheckUserNameDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserNameDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ICheckUserNameDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: CheckUserNameDTO[] | null;
    pagedContent?: CheckUserNameDTOPagedList;
    errors?: string[] | null;
}

export class CheckUserNameDTOPagedList implements ICheckUserNameDTOPagedList {
    results?: CheckUserNameDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ICheckUserNameDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CheckUserNameDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUserNameDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserNameDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ICheckUserNameDTOPagedList {
    results?: CheckUserNameDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ChildDto implements IChildDto {
    id?: number;
    ageRangeId?: number;
    genderId?: number;
    personId?: number;

    constructor(data?: IChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
        }
    }

    static fromJS(data: any): ChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        return data;
    }
}

export interface IChildDto {
    id?: number;
    ageRangeId?: number;
    genderId?: number;
    personId?: number;
}

export class ChildDtoBaseResponseDTO implements IChildDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ChildDto[] | null;
    pagedContent?: ChildDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IChildDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ChildDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ChildDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ChildDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IChildDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ChildDto[] | null;
    pagedContent?: ChildDtoPagedList;
    errors?: string[] | null;
}

export class ChildDtoPagedList implements IChildDtoPagedList {
    results?: ChildDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IChildDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ChildDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ChildDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IChildDtoPagedList {
    results?: ChildDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Claim implements IClaim {
    readonly issuer?: string | null;
    readonly originalIssuer?: string | null;
    readonly properties?: { [key: string]: string; } | null;
    subject?: ClaimsIdentity;
    readonly type?: string | null;
    readonly value?: string | null;
    readonly valueType?: string | null;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuer = _data["issuer"] !== undefined ? _data["issuer"] : <any>null;
            (<any>this).originalIssuer = _data["originalIssuer"] !== undefined ? _data["originalIssuer"] : <any>null;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] !== undefined ? _data["properties"][key] : <any>null;
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>null;
            (<any>this).type = _data["type"] !== undefined ? _data["type"] : <any>null;
            (<any>this).value = _data["value"] !== undefined ? _data["value"] : <any>null;
            (<any>this).valueType = _data["valueType"] !== undefined ? _data["valueType"] : <any>null;
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer !== undefined ? this.issuer : <any>null;
        data["originalIssuer"] = this.originalIssuer !== undefined ? this.originalIssuer : <any>null;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["valueType"] = this.valueType !== undefined ? this.valueType : <any>null;
        return data;
    }
}

export interface IClaim {
    issuer?: string | null;
    originalIssuer?: string | null;
    properties?: { [key: string]: string; } | null;
    subject?: ClaimsIdentity;
    type?: string | null;
    value?: string | null;
    valueType?: string | null;
}

export class ClaimsIdentity implements IClaimsIdentity {
    readonly authenticationType?: string | null;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | null;
    readonly claims?: Claim[] | null;
    label?: string | null;
    readonly name?: string | null;
    readonly nameClaimType?: string | null;
    readonly roleClaimType?: string | null;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).authenticationType = _data["authenticationType"] !== undefined ? _data["authenticationType"] : <any>null;
            (<any>this).isAuthenticated = _data["isAuthenticated"] !== undefined ? _data["isAuthenticated"] : <any>null;
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>null;
            this.bootstrapContext = _data["bootstrapContext"] !== undefined ? _data["bootstrapContext"] : <any>null;
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            else {
                (<any>this).claims = <any>null;
            }
            this.label = _data["label"] !== undefined ? _data["label"] : <any>null;
            (<any>this).name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).nameClaimType = _data["nameClaimType"] !== undefined ? _data["nameClaimType"] : <any>null;
            (<any>this).roleClaimType = _data["roleClaimType"] !== undefined ? _data["roleClaimType"] : <any>null;
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType !== undefined ? this.authenticationType : <any>null;
        data["isAuthenticated"] = this.isAuthenticated !== undefined ? this.isAuthenticated : <any>null;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>null;
        data["bootstrapContext"] = this.bootstrapContext !== undefined ? this.bootstrapContext : <any>null;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label !== undefined ? this.label : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nameClaimType"] = this.nameClaimType !== undefined ? this.nameClaimType : <any>null;
        data["roleClaimType"] = this.roleClaimType !== undefined ? this.roleClaimType : <any>null;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | null;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | null;
    claims?: Claim[] | null;
    label?: string | null;
    name?: string | null;
    nameClaimType?: string | null;
    roleClaimType?: string | null;
}

export class Comment implements IComment {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number | null;
    parentCommentId?: number | null;
    person?: Person;
    review?: Review;
    parentComment?: Comment;
    answers?: Comment[] | null;
    commentDetails?: CommentDetails[] | null;
    reports?: Report[] | null;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.parentCommentId = _data["parentCommentId"] !== undefined ? _data["parentCommentId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
            this.parentComment = _data["parentComment"] ? Comment.fromJS(_data["parentComment"]) : <any>null;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Comment.fromJS(item));
            }
            else {
                this.answers = <any>null;
            }
            if (Array.isArray(_data["commentDetails"])) {
                this.commentDetails = [] as any;
                for (let item of _data["commentDetails"])
                    this.commentDetails!.push(CommentDetails.fromJS(item));
            }
            else {
                this.commentDetails = <any>null;
            }
            if (Array.isArray(_data["reports"])) {
                this.reports = [] as any;
                for (let item of _data["reports"])
                    this.reports!.push(Report.fromJS(item));
            }
            else {
                this.reports = <any>null;
            }
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["parentCommentId"] = this.parentCommentId !== undefined ? this.parentCommentId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["parentComment"] = this.parentComment ? this.parentComment.toJSON() : <any>null;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.commentDetails)) {
            data["commentDetails"] = [];
            for (let item of this.commentDetails)
                data["commentDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        return data;
    }
}

export interface IComment {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    reviewId?: number | null;
    parentCommentId?: number | null;
    person?: Person;
    review?: Review;
    parentComment?: Comment;
    answers?: Comment[] | null;
    commentDetails?: CommentDetails[] | null;
    reports?: Report[] | null;
}

export class CommentDetails implements ICommentDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    commentId?: number;
    text?: string | null;
    comment?: Comment;

    constructor(data?: ICommentDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>null;
        }
    }

    static fromJS(data: any): CommentDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>null;
        return data;
    }
}

export interface ICommentDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    commentId?: number;
    text?: string | null;
    comment?: Comment;
}

export class CommentDetailsDto implements ICommentDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    answers?: CommentDetailsDto[] | null;
    text?: string | null;
    answersQuantity?: number;
    createDate?: Date;
    edited?: boolean;

    constructor(data?: ICommentDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.person = _data["person"] ? ReadPersonDTO.fromJS(_data["person"]) : <any>null;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(CommentDetailsDto.fromJS(item));
            }
            else {
                this.answers = <any>null;
            }
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.answersQuantity = _data["answersQuantity"] !== undefined ? _data["answersQuantity"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.edited = _data["edited"] !== undefined ? _data["edited"] : <any>null;
        }
    }

    static fromJS(data: any): CommentDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["answersQuantity"] = this.answersQuantity !== undefined ? this.answersQuantity : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["edited"] = this.edited !== undefined ? this.edited : <any>null;
        return data;
    }
}

export interface ICommentDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    answers?: CommentDetailsDto[] | null;
    text?: string | null;
    answersQuantity?: number;
    createDate?: Date;
    edited?: boolean;
}

export class CommentDetailsDtoBaseResponseDTO implements ICommentDetailsDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: CommentDetailsDto[] | null;
    pagedContent?: CommentDetailsDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: ICommentDetailsDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CommentDetailsDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? CommentDetailsDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): CommentDetailsDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailsDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ICommentDetailsDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: CommentDetailsDto[] | null;
    pagedContent?: CommentDetailsDtoPagedList;
    errors?: string[] | null;
}

export class CommentDetailsDtoPagedList implements ICommentDetailsDtoPagedList {
    results?: CommentDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ICommentDetailsDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CommentDetailsDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): CommentDetailsDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailsDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ICommentDetailsDtoPagedList {
    results?: CommentDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ConfirmAccountEmailDTO implements IConfirmAccountEmailDTO {
    userId!: number;
    keycode!: number;

    constructor(data?: IConfirmAccountEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.keycode = _data["keycode"] !== undefined ? _data["keycode"] : <any>null;
        }
    }

    static fromJS(data: any): ConfirmAccountEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAccountEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["keycode"] = this.keycode !== undefined ? this.keycode : <any>null;
        return data;
    }
}

export interface IConfirmAccountEmailDTO {
    userId: number;
    keycode: number;
}

export class Content implements IContent {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformCategoryId?: number;
    externalId?: string | null;
    platformCategory?: PlatformCategory;
    reviews?: Review[] | null;
    contentGenre?: ContentGenre[] | null;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.platformCategoryId = _data["platformCategoryId"] !== undefined ? _data["platformCategoryId"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.platformCategory = _data["platformCategory"] ? PlatformCategory.fromJS(_data["platformCategory"]) : <any>null;
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
            else {
                this.reviews = <any>null;
            }
            if (Array.isArray(_data["contentGenre"])) {
                this.contentGenre = [] as any;
                for (let item of _data["contentGenre"])
                    this.contentGenre!.push(ContentGenre.fromJS(item));
            }
            else {
                this.contentGenre = <any>null;
            }
        }
    }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["platformCategoryId"] = this.platformCategoryId !== undefined ? this.platformCategoryId : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["platformCategory"] = this.platformCategory ? this.platformCategory.toJSON() : <any>null;
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.contentGenre)) {
            data["contentGenre"] = [];
            for (let item of this.contentGenre)
                data["contentGenre"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContent {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformCategoryId?: number;
    externalId?: string | null;
    platformCategory?: PlatformCategory;
    reviews?: Review[] | null;
    contentGenre?: ContentGenre[] | null;
}

export class ContentDetailsDTO implements IContentDetailsDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    description?: string | null;
    category?: PlatformCategoryDTO;
    releaseDate?: Date | null;
    averageRating?: number | null;
    imageUrl?: string | null;
    tags?: string[] | null;
    reviewCount?: number | null;
    platformId?: number | null;

    constructor(data?: IContentDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.category = _data["category"] ? PlatformCategoryDTO.fromJS(_data["category"]) : <any>null;
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>null;
            this.averageRating = _data["averageRating"] !== undefined ? _data["averageRating"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.reviewCount = _data["reviewCount"] !== undefined ? _data["reviewCount"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
        }
    }

    static fromJS(data: any): ContentDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>null;
        data["averageRating"] = this.averageRating !== undefined ? this.averageRating : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["reviewCount"] = this.reviewCount !== undefined ? this.reviewCount : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        return data;
    }
}

export interface IContentDetailsDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    description?: string | null;
    category?: PlatformCategoryDTO;
    releaseDate?: Date | null;
    averageRating?: number | null;
    imageUrl?: string | null;
    tags?: string[] | null;
    reviewCount?: number | null;
    platformId?: number | null;
}

export class ContentDetailsDTOBaseResponseDTO implements IContentDetailsDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ContentDetailsDTO[] | null;
    pagedContent?: ContentDetailsDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IContentDetailsDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ContentDetailsDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ContentDetailsDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ContentDetailsDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetailsDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IContentDetailsDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ContentDetailsDTO[] | null;
    pagedContent?: ContentDetailsDTOPagedList;
    errors?: string[] | null;
}

export class ContentDetailsDTOPagedList implements IContentDetailsDTOPagedList {
    results?: ContentDetailsDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IContentDetailsDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ContentDetailsDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ContentDetailsDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetailsDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IContentDetailsDTOPagedList {
    results?: ContentDetailsDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ContentGenre implements IContentGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    contentId?: number;
    genreId?: number;
    content?: Content;
    genre?: Genre;

    constructor(data?: IContentGenre) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.genreId = _data["genreId"] !== undefined ? _data["genreId"] : <any>null;
            this.content = _data["content"] ? Content.fromJS(_data["content"]) : <any>null;
            this.genre = _data["genre"] ? Genre.fromJS(_data["genre"]) : <any>null;
        }
    }

    static fromJS(data: any): ContentGenre {
        data = typeof data === 'object' ? data : {};
        let result = new ContentGenre();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["genreId"] = this.genreId !== undefined ? this.genreId : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        data["genre"] = this.genre ? this.genre.toJSON() : <any>null;
        return data;
    }
}

export interface IContentGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    contentId?: number;
    genreId?: number;
    content?: Content;
    genre?: Genre;
}

export class ContentListItemDTO implements IContentListItemDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    description?: string | null;
    category?: PlatformCategoryDTO;
    releaseDate?: Date | null;
    averageRating?: number | null;
    imageUrl?: string | null;
    tags?: string[] | null;
    platformId?: number;

    constructor(data?: IContentListItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.category = _data["category"] ? PlatformCategoryDTO.fromJS(_data["category"]) : <any>null;
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>null;
            this.averageRating = _data["averageRating"] !== undefined ? _data["averageRating"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
        }
    }

    static fromJS(data: any): ContentListItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContentListItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>null;
        data["averageRating"] = this.averageRating !== undefined ? this.averageRating : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        return data;
    }
}

export interface IContentListItemDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    description?: string | null;
    category?: PlatformCategoryDTO;
    releaseDate?: Date | null;
    averageRating?: number | null;
    imageUrl?: string | null;
    tags?: string[] | null;
    platformId?: number;
}

export class ContentListItemDTOBaseResponseDTO implements IContentListItemDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ContentListItemDTO[] | null;
    pagedContent?: ContentListItemDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IContentListItemDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ContentListItemDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ContentListItemDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ContentListItemDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContentListItemDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IContentListItemDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ContentListItemDTO[] | null;
    pagedContent?: ContentListItemDTOPagedList;
    errors?: string[] | null;
}

export class ContentListItemDTOPagedList implements IContentListItemDTOPagedList {
    results?: ContentListItemDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IContentListItemDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ContentListItemDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ContentListItemDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ContentListItemDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IContentListItemDTOPagedList {
    results?: ContentListItemDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateChildDto implements ICreateChildDto {
    ageRangeId?: number;
    genderId?: number;

    constructor(data?: ICreateChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface ICreateChildDto {
    ageRangeId?: number;
    genderId?: number;
}

export class CreateCommentDto implements ICreateCommentDto {
    reviewId?: number;
    text?: string | null;

    constructor(data?: ICreateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
        }
    }

    static fromJS(data: any): CreateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data;
    }
}

export interface ICreateCommentDto {
    reviewId?: number;
    text?: string | null;
}

export class CreateReportDto implements ICreateReportDto {
    reportedPersonId?: number | null;
    reasonId?: number;
    commentId?: number | null;
    reviewId?: number | null;
    details?: string | null;

    constructor(data?: ICreateReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportedPersonId = _data["reportedPersonId"] !== undefined ? _data["reportedPersonId"] : <any>null;
            this.reasonId = _data["reasonId"] !== undefined ? _data["reasonId"] : <any>null;
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
        }
    }

    static fromJS(data: any): CreateReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportedPersonId"] = this.reportedPersonId !== undefined ? this.reportedPersonId : <any>null;
        data["reasonId"] = this.reasonId !== undefined ? this.reasonId : <any>null;
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        return data;
    }
}

export interface ICreateReportDto {
    reportedPersonId?: number | null;
    reasonId?: number;
    commentId?: number | null;
    reviewId?: number | null;
    details?: string | null;
}

export class CreateReviewDto implements ICreateReviewDto {
    contentId?: number | null;
    externalContentId?: string | null;
    platformId?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;

    constructor(data?: ICreateReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.externalContentId = _data["externalContentId"] !== undefined ? _data["externalContentId"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
        }
    }

    static fromJS(data: any): CreateReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["externalContentId"] = this.externalContentId !== undefined ? this.externalContentId : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        return data;
    }
}

export interface ICreateReviewDto {
    contentId?: number | null;
    externalContentId?: string | null;
    platformId?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;
}

export class CreateUserDTO implements ICreateUserDTO {
    userName!: string;
    password!: string;
    rePassword!: string;
    firstName!: string;
    lastName!: string;
    email!: string;
    personDetails!: PersonOnCreateUserDTO;

    constructor(data?: ICreateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personDetails = new PersonOnCreateUserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rePassword = _data["rePassword"] !== undefined ? _data["rePassword"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.personDetails = _data["personDetails"] ? PersonOnCreateUserDTO.fromJS(_data["personDetails"]) : new PersonOnCreateUserDTO();
        }
    }

    static fromJS(data: any): CreateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rePassword"] = this.rePassword !== undefined ? this.rePassword : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["personDetails"] = this.personDetails ? this.personDetails.toJSON() : <any>null;
        return data;
    }
}

export interface ICreateUserDTO {
    userName: string;
    password: string;
    rePassword: string;
    firstName: string;
    lastName: string;
    email: string;
    personDetails: PersonOnCreateUserDTO;
}

export class Gender implements IGender {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isBinary?: boolean;
    people?: Person[] | null;
    children?: PersonChild[] | null;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isBinary = _data["isBinary"] !== undefined ? _data["isBinary"] : <any>null;
            if (Array.isArray(_data["people"])) {
                this.people = [] as any;
                for (let item of _data["people"])
                    this.people!.push(Person.fromJS(item));
            }
            else {
                this.people = <any>null;
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isBinary"] = this.isBinary !== undefined ? this.isBinary : <any>null;
        if (Array.isArray(this.people)) {
            data["people"] = [];
            for (let item of this.people)
                data["people"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGender {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isBinary?: boolean;
    people?: Person[] | null;
    children?: PersonChild[] | null;
}

export class GenderDto implements IGenderDto {
    id?: number;
    name?: string | null;
    isBinary?: boolean;

    constructor(data?: IGenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isBinary = _data["isBinary"] !== undefined ? _data["isBinary"] : <any>null;
        }
    }

    static fromJS(data: any): GenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isBinary"] = this.isBinary !== undefined ? this.isBinary : <any>null;
        return data;
    }
}

export interface IGenderDto {
    id?: number;
    name?: string | null;
    isBinary?: boolean;
}

export class GenderDtoBaseResponseDTO implements IGenderDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: GenderDto[] | null;
    pagedContent?: GenderDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IGenderDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(GenderDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? GenderDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): GenderDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GenderDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IGenderDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: GenderDto[] | null;
    pagedContent?: GenderDtoPagedList;
    errors?: string[] | null;
}

export class GenderDtoPagedList implements IGenderDtoPagedList {
    results?: GenderDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGenderDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GenderDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): GenderDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new GenderDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IGenderDtoPagedList {
    results?: GenderDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Genre implements IGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    contentGenre?: ContentGenre[] | null;

    constructor(data?: IGenre) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["contentGenre"])) {
                this.contentGenre = [] as any;
                for (let item of _data["contentGenre"])
                    this.contentGenre!.push(ContentGenre.fromJS(item));
            }
            else {
                this.contentGenre = <any>null;
            }
        }
    }

    static fromJS(data: any): Genre {
        data = typeof data === 'object' ? data : {};
        let result = new Genre();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.contentGenre)) {
            data["contentGenre"] = [];
            for (let item of this.contentGenre)
                data["contentGenre"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGenre {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    contentGenre?: ContentGenre[] | null;
}

export class GenreDTO implements IGenreDTO {
    id?: number | null;
    name?: string | null;

    constructor(data?: IGenreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): GenreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IGenreDTO {
    id?: number | null;
    name?: string | null;
}

export class GiveAwardDto implements IGiveAwardDto {
    awardId?: number;
    reviewId?: number;

    constructor(data?: IGiveAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.awardId = _data["awardId"] !== undefined ? _data["awardId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
        }
    }

    static fromJS(data: any): GiveAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new GiveAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["awardId"] = this.awardId !== undefined ? this.awardId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        return data;
    }
}

export interface IGiveAwardDto {
    awardId?: number;
    reviewId?: number;
}

export class GivenAwardDto implements IGivenAwardDto {
    reviewerReceived?: number;
    person?: ReadPersonDTO;
    review?: ReviewDetailsDto;
    award?: AwardDetailsDto;

    constructor(data?: IGivenAwardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewerReceived = _data["reviewerReceived"] !== undefined ? _data["reviewerReceived"] : <any>null;
            this.person = _data["person"] ? ReadPersonDTO.fromJS(_data["person"]) : <any>null;
            this.review = _data["review"] ? ReviewDetailsDto.fromJS(_data["review"]) : <any>null;
            this.award = _data["award"] ? AwardDetailsDto.fromJS(_data["award"]) : <any>null;
        }
    }

    static fromJS(data: any): GivenAwardDto {
        data = typeof data === 'object' ? data : {};
        let result = new GivenAwardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewerReceived"] = this.reviewerReceived !== undefined ? this.reviewerReceived : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["award"] = this.award ? this.award.toJSON() : <any>null;
        return data;
    }
}

export interface IGivenAwardDto {
    reviewerReceived?: number;
    person?: ReadPersonDTO;
    review?: ReviewDetailsDto;
    award?: AwardDetailsDto;
}

export class GivenAwardDtoBaseResponseDTO implements IGivenAwardDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: GivenAwardDto[] | null;
    pagedContent?: GivenAwardDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IGivenAwardDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(GivenAwardDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? GivenAwardDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): GivenAwardDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GivenAwardDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IGivenAwardDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: GivenAwardDto[] | null;
    pagedContent?: GivenAwardDtoPagedList;
    errors?: string[] | null;
}

export class GivenAwardDtoPagedList implements IGivenAwardDtoPagedList {
    results?: GivenAwardDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGivenAwardDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GivenAwardDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): GivenAwardDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new GivenAwardDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IGivenAwardDtoPagedList {
    results?: GivenAwardDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class LoginRequestByEmailDTO implements ILoginRequestByEmailDTO {
    email!: string;
    password!: string;

    constructor(data?: ILoginRequestByEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestByEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestByEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestByEmailDTO {
    email: string;
    password: string;
}

export class LoginRequestByUserNameDTO implements ILoginRequestByUserNameDTO {
    userName!: string;
    password!: string;

    constructor(data?: ILoginRequestByUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestByUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestByUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginRequestByUserNameDTO {
    userName: string;
    password: string;
}

export class MovieDTO implements IMovieDTO {
    adult?: boolean | null;
    backdrop_path?: string | null;
    belongs_to_collection?: any | null;
    budget?: number | null;
    genres?: GenreDTO[] | null;
    homepage?: string | null;
    id?: number | null;
    imdb_id?: string | null;
    original_language?: string | null;
    original_title?: string | null;
    overview?: string | null;
    popularity?: number | null;
    poster_path?: string | null;
    production_companies?: ProductionCompanyDTO[] | null;
    production_countries?: ProductionCountryDTO[] | null;
    release_date?: string | null;
    revenue?: number | null;
    runtime?: number | null;
    spoken_languages?: SpokenLanguageDTO[] | null;
    status?: string | null;
    tagline?: string | null;
    title?: string | null;
    video?: boolean | null;
    vote_average?: number | null;
    vote_count?: number | null;

    constructor(data?: IMovieDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adult = _data["adult"] !== undefined ? _data["adult"] : <any>null;
            this.backdrop_path = _data["backdrop_path"] !== undefined ? _data["backdrop_path"] : <any>null;
            this.belongs_to_collection = _data["belongs_to_collection"] !== undefined ? _data["belongs_to_collection"] : <any>null;
            this.budget = _data["budget"] !== undefined ? _data["budget"] : <any>null;
            if (Array.isArray(_data["genres"])) {
                this.genres = [] as any;
                for (let item of _data["genres"])
                    this.genres!.push(GenreDTO.fromJS(item));
            }
            else {
                this.genres = <any>null;
            }
            this.homepage = _data["homepage"] !== undefined ? _data["homepage"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.imdb_id = _data["imdb_id"] !== undefined ? _data["imdb_id"] : <any>null;
            this.original_language = _data["original_language"] !== undefined ? _data["original_language"] : <any>null;
            this.original_title = _data["original_title"] !== undefined ? _data["original_title"] : <any>null;
            this.overview = _data["overview"] !== undefined ? _data["overview"] : <any>null;
            this.popularity = _data["popularity"] !== undefined ? _data["popularity"] : <any>null;
            this.poster_path = _data["poster_path"] !== undefined ? _data["poster_path"] : <any>null;
            if (Array.isArray(_data["production_companies"])) {
                this.production_companies = [] as any;
                for (let item of _data["production_companies"])
                    this.production_companies!.push(ProductionCompanyDTO.fromJS(item));
            }
            else {
                this.production_companies = <any>null;
            }
            if (Array.isArray(_data["production_countries"])) {
                this.production_countries = [] as any;
                for (let item of _data["production_countries"])
                    this.production_countries!.push(ProductionCountryDTO.fromJS(item));
            }
            else {
                this.production_countries = <any>null;
            }
            this.release_date = _data["release_date"] !== undefined ? _data["release_date"] : <any>null;
            this.revenue = _data["revenue"] !== undefined ? _data["revenue"] : <any>null;
            this.runtime = _data["runtime"] !== undefined ? _data["runtime"] : <any>null;
            if (Array.isArray(_data["spoken_languages"])) {
                this.spoken_languages = [] as any;
                for (let item of _data["spoken_languages"])
                    this.spoken_languages!.push(SpokenLanguageDTO.fromJS(item));
            }
            else {
                this.spoken_languages = <any>null;
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.tagline = _data["tagline"] !== undefined ? _data["tagline"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.video = _data["video"] !== undefined ? _data["video"] : <any>null;
            this.vote_average = _data["vote_average"] !== undefined ? _data["vote_average"] : <any>null;
            this.vote_count = _data["vote_count"] !== undefined ? _data["vote_count"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adult"] = this.adult !== undefined ? this.adult : <any>null;
        data["backdrop_path"] = this.backdrop_path !== undefined ? this.backdrop_path : <any>null;
        data["belongs_to_collection"] = this.belongs_to_collection !== undefined ? this.belongs_to_collection : <any>null;
        data["budget"] = this.budget !== undefined ? this.budget : <any>null;
        if (Array.isArray(this.genres)) {
            data["genres"] = [];
            for (let item of this.genres)
                data["genres"].push(item.toJSON());
        }
        data["homepage"] = this.homepage !== undefined ? this.homepage : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["imdb_id"] = this.imdb_id !== undefined ? this.imdb_id : <any>null;
        data["original_language"] = this.original_language !== undefined ? this.original_language : <any>null;
        data["original_title"] = this.original_title !== undefined ? this.original_title : <any>null;
        data["overview"] = this.overview !== undefined ? this.overview : <any>null;
        data["popularity"] = this.popularity !== undefined ? this.popularity : <any>null;
        data["poster_path"] = this.poster_path !== undefined ? this.poster_path : <any>null;
        if (Array.isArray(this.production_companies)) {
            data["production_companies"] = [];
            for (let item of this.production_companies)
                data["production_companies"].push(item.toJSON());
        }
        if (Array.isArray(this.production_countries)) {
            data["production_countries"] = [];
            for (let item of this.production_countries)
                data["production_countries"].push(item.toJSON());
        }
        data["release_date"] = this.release_date !== undefined ? this.release_date : <any>null;
        data["revenue"] = this.revenue !== undefined ? this.revenue : <any>null;
        data["runtime"] = this.runtime !== undefined ? this.runtime : <any>null;
        if (Array.isArray(this.spoken_languages)) {
            data["spoken_languages"] = [];
            for (let item of this.spoken_languages)
                data["spoken_languages"].push(item.toJSON());
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["tagline"] = this.tagline !== undefined ? this.tagline : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["video"] = this.video !== undefined ? this.video : <any>null;
        data["vote_average"] = this.vote_average !== undefined ? this.vote_average : <any>null;
        data["vote_count"] = this.vote_count !== undefined ? this.vote_count : <any>null;
        return data;
    }
}

export interface IMovieDTO {
    adult?: boolean | null;
    backdrop_path?: string | null;
    belongs_to_collection?: any | null;
    budget?: number | null;
    genres?: GenreDTO[] | null;
    homepage?: string | null;
    id?: number | null;
    imdb_id?: string | null;
    original_language?: string | null;
    original_title?: string | null;
    overview?: string | null;
    popularity?: number | null;
    poster_path?: string | null;
    production_companies?: ProductionCompanyDTO[] | null;
    production_countries?: ProductionCountryDTO[] | null;
    release_date?: string | null;
    revenue?: number | null;
    runtime?: number | null;
    spoken_languages?: SpokenLanguageDTO[] | null;
    status?: string | null;
    tagline?: string | null;
    title?: string | null;
    video?: boolean | null;
    vote_average?: number | null;
    vote_count?: number | null;
}

export class MovieDTOBaseResponseDTO implements IMovieDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: MovieDTO[] | null;
    pagedContent?: MovieDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IMovieDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(MovieDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? MovieDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): MovieDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IMovieDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: MovieDTO[] | null;
    pagedContent?: MovieDTOPagedList;
    errors?: string[] | null;
}

export class MovieDTOPagedList implements IMovieDTOPagedList {
    results?: MovieDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMovieDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MovieDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IMovieDTOPagedList {
    results?: MovieDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ObjectBaseResponseDTO implements IObjectBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: any[] | null;
    pagedContent?: ObjectPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IObjectBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(item);
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ObjectPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ObjectBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item);
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IObjectBaseResponseDTO {
    isSuccess?: boolean;
    content?: any[] | null;
    pagedContent?: ObjectPagedList;
    errors?: string[] | null;
}

export class ObjectPagedList implements IObjectPagedList {
    results?: any[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IObjectPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ObjectPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IObjectPagedList {
    results?: any[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Operation implements IOperation {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    operationTypeId?: number;
    coins?: number;
    person?: Person;
    operationType?: OperationType;

    constructor(data?: IOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.operationTypeId = _data["operationTypeId"] !== undefined ? _data["operationTypeId"] : <any>null;
            this.coins = _data["coins"] !== undefined ? _data["coins"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.operationType = _data["operationType"] ? OperationType.fromJS(_data["operationType"]) : <any>null;
        }
    }

    static fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["operationTypeId"] = this.operationTypeId !== undefined ? this.operationTypeId : <any>null;
        data["coins"] = this.coins !== undefined ? this.coins : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["operationType"] = this.operationType ? this.operationType.toJSON() : <any>null;
        return data;
    }
}

export interface IOperation {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    operationTypeId?: number;
    coins?: number;
    person?: Person;
    operationType?: OperationType;
}

export class OperationType implements IOperationType {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    type?: string | null;
    credit?: boolean;
    operations?: Operation[] | null;

    constructor(data?: IOperationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.credit = _data["credit"] !== undefined ? _data["credit"] : <any>null;
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(Operation.fromJS(item));
            }
            else {
                this.operations = <any>null;
            }
        }
    }

    static fromJS(data: any): OperationType {
        data = typeof data === 'object' ? data : {};
        let result = new OperationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["credit"] = this.credit !== undefined ? this.credit : <any>null;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOperationType {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    type?: string | null;
    credit?: boolean;
    operations?: Operation[] | null;
}

export class Person implements IPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    imageURL?: string | null;
    birthDate?: Date;
    userId?: number;
    genderId?: number;
    balance?: number;
    user?: ApplicationUser;
    gender?: Gender;
    children?: PersonChild[] | null;
    reviews?: Review[] | null;
    comments?: Comment[] | null;
    premiumPerson?: PremiumPerson[] | null;
    awardsGiven?: AwardPerson[] | null;
    operations?: Operation[] | null;
    reports?: Report[] | null;
    reportedIn?: Report[] | null;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.imageURL = _data["imageURL"] !== undefined ? _data["imageURL"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PersonChild.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(Review.fromJS(item));
            }
            else {
                this.reviews = <any>null;
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            else {
                this.comments = <any>null;
            }
            if (Array.isArray(_data["premiumPerson"])) {
                this.premiumPerson = [] as any;
                for (let item of _data["premiumPerson"])
                    this.premiumPerson!.push(PremiumPerson.fromJS(item));
            }
            else {
                this.premiumPerson = <any>null;
            }
            if (Array.isArray(_data["awardsGiven"])) {
                this.awardsGiven = [] as any;
                for (let item of _data["awardsGiven"])
                    this.awardsGiven!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awardsGiven = <any>null;
            }
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(Operation.fromJS(item));
            }
            else {
                this.operations = <any>null;
            }
            if (Array.isArray(_data["reports"])) {
                this.reports = [] as any;
                for (let item of _data["reports"])
                    this.reports!.push(Report.fromJS(item));
            }
            else {
                this.reports = <any>null;
            }
            if (Array.isArray(_data["reportedIn"])) {
                this.reportedIn = [] as any;
                for (let item of _data["reportedIn"])
                    this.reportedIn!.push(Report.fromJS(item));
            }
            else {
                this.reportedIn = <any>null;
            }
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["imageURL"] = this.imageURL !== undefined ? this.imageURL : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.premiumPerson)) {
            data["premiumPerson"] = [];
            for (let item of this.premiumPerson)
                data["premiumPerson"].push(item.toJSON());
        }
        if (Array.isArray(this.awardsGiven)) {
            data["awardsGiven"] = [];
            for (let item of this.awardsGiven)
                data["awardsGiven"].push(item.toJSON());
        }
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        if (Array.isArray(this.reportedIn)) {
            data["reportedIn"] = [];
            for (let item of this.reportedIn)
                data["reportedIn"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    imageURL?: string | null;
    birthDate?: Date;
    userId?: number;
    genderId?: number;
    balance?: number;
    user?: ApplicationUser;
    gender?: Gender;
    children?: PersonChild[] | null;
    reviews?: Review[] | null;
    comments?: Comment[] | null;
    premiumPerson?: PremiumPerson[] | null;
    awardsGiven?: AwardPerson[] | null;
    operations?: Operation[] | null;
    reports?: Report[] | null;
    reportedIn?: Report[] | null;
}

export class PersonChild implements IPersonChild {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    genderId?: number;
    ageRangeId?: number;
    person?: Person;
    gender?: Gender;
    ageRange?: AgeRange;

    constructor(data?: IPersonChild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
            this.ageRangeId = _data["ageRangeId"] !== undefined ? _data["ageRangeId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            this.ageRange = _data["ageRange"] ? AgeRange.fromJS(_data["ageRange"]) : <any>null;
        }
    }

    static fromJS(data: any): PersonChild {
        data = typeof data === 'object' ? data : {};
        let result = new PersonChild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        data["ageRangeId"] = this.ageRangeId !== undefined ? this.ageRangeId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        data["ageRange"] = this.ageRange ? this.ageRange.toJSON() : <any>null;
        return data;
    }
}

export interface IPersonChild {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    genderId?: number;
    ageRangeId?: number;
    person?: Person;
    gender?: Gender;
    ageRange?: AgeRange;
}

export class PersonOnCreateUserDTO implements IPersonOnCreateUserDTO {
    birthDate!: Date;
    genderId!: number;

    constructor(data?: IPersonOnCreateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): PersonOnCreateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOnCreateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface IPersonOnCreateUserDTO {
    birthDate: Date;
    genderId: number;
}

export class Platform implements IPlatform {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    url?: string | null;
    platformCategories?: PlatformCategory[] | null;

    constructor(data?: IPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            if (Array.isArray(_data["platformCategories"])) {
                this.platformCategories = [] as any;
                for (let item of _data["platformCategories"])
                    this.platformCategories!.push(PlatformCategory.fromJS(item));
            }
            else {
                this.platformCategories = <any>null;
            }
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        if (Array.isArray(this.platformCategories)) {
            data["platformCategories"] = [];
            for (let item of this.platformCategories)
                data["platformCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlatform {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    url?: string | null;
    platformCategories?: PlatformCategory[] | null;
}

export class PlatformCategory implements IPlatformCategory {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformId?: number;
    platform?: Platform;
    contents?: Content[] | null;

    constructor(data?: IPlatformCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
            this.platform = _data["platform"] ? Platform.fromJS(_data["platform"]) : <any>null;
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(Content.fromJS(item));
            }
            else {
                this.contents = <any>null;
            }
        }
    }

    static fromJS(data: any): PlatformCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        data["platform"] = this.platform ? this.platform.toJSON() : <any>null;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPlatformCategory {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    platformId?: number;
    platform?: Platform;
    contents?: Content[] | null;
}

export class PlatformCategoryDTO implements IPlatformCategoryDTO {
    platformId?: number;
    platformCategory?: string | null;

    constructor(data?: IPlatformCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
            this.platformCategory = _data["platformCategory"] !== undefined ? _data["platformCategory"] : <any>null;
        }
    }

    static fromJS(data: any): PlatformCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        data["platformCategory"] = this.platformCategory !== undefined ? this.platformCategory : <any>null;
        return data;
    }
}

export interface IPlatformCategoryDTO {
    platformId?: number;
    platformCategory?: string | null;
}

export enum PlatformEnum {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class PremiumPerson implements IPremiumPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    tierPlanId?: number;
    startDate?: Date;
    endDate?: Date | null;
    autoRenewal?: boolean;
    person?: Person;
    tierPlan?: TierPlan;

    constructor(data?: IPremiumPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.tierPlanId = _data["tierPlanId"] !== undefined ? _data["tierPlanId"] : <any>null;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
            this.autoRenewal = _data["autoRenewal"] !== undefined ? _data["autoRenewal"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.tierPlan = _data["tierPlan"] ? TierPlan.fromJS(_data["tierPlan"]) : <any>null;
        }
    }

    static fromJS(data: any): PremiumPerson {
        data = typeof data === 'object' ? data : {};
        let result = new PremiumPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["tierPlanId"] = this.tierPlanId !== undefined ? this.tierPlanId : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["autoRenewal"] = this.autoRenewal !== undefined ? this.autoRenewal : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["tierPlan"] = this.tierPlan ? this.tierPlan.toJSON() : <any>null;
        return data;
    }
}

export interface IPremiumPerson {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    tierPlanId?: number;
    startDate?: Date;
    endDate?: Date | null;
    autoRenewal?: boolean;
    person?: Person;
    tierPlan?: TierPlan;
}

export class ProductionCompanyDTO implements IProductionCompanyDTO {
    id?: number | null;
    logo_path?: string | null;
    name?: string | null;
    origin_country?: string | null;

    constructor(data?: IProductionCompanyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.logo_path = _data["logo_path"] !== undefined ? _data["logo_path"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.origin_country = _data["origin_country"] !== undefined ? _data["origin_country"] : <any>null;
        }
    }

    static fromJS(data: any): ProductionCompanyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductionCompanyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["logo_path"] = this.logo_path !== undefined ? this.logo_path : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["origin_country"] = this.origin_country !== undefined ? this.origin_country : <any>null;
        return data;
    }
}

export interface IProductionCompanyDTO {
    id?: number | null;
    logo_path?: string | null;
    name?: string | null;
    origin_country?: string | null;
}

export class ProductionCountryDTO implements IProductionCountryDTO {
    iso_3166_1?: string | null;
    name?: string | null;

    constructor(data?: IProductionCountryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iso_3166_1 = _data["iso_3166_1"] !== undefined ? _data["iso_3166_1"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProductionCountryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductionCountryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iso_3166_1"] = this.iso_3166_1 !== undefined ? this.iso_3166_1 : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IProductionCountryDTO {
    iso_3166_1?: string | null;
    name?: string | null;
}

export class ReadAwardDTO implements IReadAwardDTO {
    name?: string | null;
    quantity?: number;

    constructor(data?: IReadAwardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
        }
    }

    static fromJS(data: any): ReadAwardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAwardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        return data;
    }
}

export interface IReadAwardDTO {
    name?: string | null;
    quantity?: number;
}

export class ReadContentDTO implements IReadContentDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    imageUrl?: string | null;
    platformCategory?: number;
    platformId?: number | null;

    constructor(data?: IReadContentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.platformCategory = _data["platformCategory"] !== undefined ? _data["platformCategory"] : <any>null;
            this.platformId = _data["platformId"] !== undefined ? _data["platformId"] : <any>null;
        }
    }

    static fromJS(data: any): ReadContentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadContentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["platformCategory"] = this.platformCategory !== undefined ? this.platformCategory : <any>null;
        data["platformId"] = this.platformId !== undefined ? this.platformId : <any>null;
        return data;
    }
}

export interface IReadContentDTO {
    id?: number;
    externalId?: string | null;
    name?: string | null;
    imageUrl?: string | null;
    platformCategory?: number;
    platformId?: number | null;
}

export class ReadPersonDTO implements IReadPersonDTO {
    id?: number;
    userId?: number;
    username?: string | null;
    name?: string | null;
    imageURL?: string | null;
    birthDate?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    genderId?: number;

    constructor(data?: IReadPersonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.imageURL = _data["imageURL"] !== undefined ? _data["imageURL"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.genderId = _data["genderId"] !== undefined ? _data["genderId"] : <any>null;
        }
    }

    static fromJS(data: any): ReadPersonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPersonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["imageURL"] = this.imageURL !== undefined ? this.imageURL : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["genderId"] = this.genderId !== undefined ? this.genderId : <any>null;
        return data;
    }
}

export interface IReadPersonDTO {
    id?: number;
    userId?: number;
    username?: string | null;
    name?: string | null;
    imageURL?: string | null;
    birthDate?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    genderId?: number;
}

export class ReadProfileDTO implements IReadProfileDTO {
    personId?: number;
    userId?: number;
    imageURL?: string | null;
    name?: string | null;
    username?: string | null;
    childrens?: ChildDto[] | null;
    awards?: ReadAwardDTO[] | null;

    constructor(data?: IReadProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.imageURL = _data["imageURL"] !== undefined ? _data["imageURL"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            if (Array.isArray(_data["childrens"])) {
                this.childrens = [] as any;
                for (let item of _data["childrens"])
                    this.childrens!.push(ChildDto.fromJS(item));
            }
            else {
                this.childrens = <any>null;
            }
            if (Array.isArray(_data["awards"])) {
                this.awards = [] as any;
                for (let item of _data["awards"])
                    this.awards!.push(ReadAwardDTO.fromJS(item));
            }
            else {
                this.awards = <any>null;
            }
        }
    }

    static fromJS(data: any): ReadProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["imageURL"] = this.imageURL !== undefined ? this.imageURL : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        if (Array.isArray(this.childrens)) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReadProfileDTO {
    personId?: number;
    userId?: number;
    imageURL?: string | null;
    name?: string | null;
    username?: string | null;
    childrens?: ChildDto[] | null;
    awards?: ReadAwardDTO[] | null;
}

export class ReadProfileDTOBaseResponseDTO implements IReadProfileDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReadProfileDTO[] | null;
    pagedContent?: ReadProfileDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReadProfileDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReadProfileDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReadProfileDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReadProfileDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadProfileDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReadProfileDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReadProfileDTO[] | null;
    pagedContent?: ReadProfileDTOPagedList;
    errors?: string[] | null;
}

export class ReadProfileDTOIEnumerableBaseResponseDTO implements IReadProfileDTOIEnumerableBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReadProfileDTO[][] | null;
    pagedContent?: ReadProfileDTOIEnumerablePagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReadProfileDTOIEnumerableBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(item);
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReadProfileDTOIEnumerablePagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReadProfileDTOIEnumerableBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadProfileDTOIEnumerableBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item);
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReadProfileDTOIEnumerableBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReadProfileDTO[][] | null;
    pagedContent?: ReadProfileDTOIEnumerablePagedList;
    errors?: string[] | null;
}

export class ReadProfileDTOIEnumerablePagedList implements IReadProfileDTOIEnumerablePagedList {
    results?: ReadProfileDTO[][] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReadProfileDTOIEnumerablePagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReadProfileDTOIEnumerablePagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReadProfileDTOIEnumerablePagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReadProfileDTOIEnumerablePagedList {
    results?: ReadProfileDTO[][] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReadProfileDTOPagedList implements IReadProfileDTOPagedList {
    results?: ReadProfileDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReadProfileDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReadProfileDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReadProfileDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReadProfileDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReadProfileDTOPagedList {
    results?: ReadProfileDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReadUserDTO implements IReadUserDTO {
    id?: number;
    firstName?: string | null;
    lastName?: string | null;
    userName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnabled?: boolean;
    isAdminUser?: boolean;
    lockoutEnd?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    isConfirmEmailTokenSent?: boolean;
    associatedWithPerson?: ReadPersonDTO;

    constructor(data?: IReadUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = _data["twoFactorEnabled"] !== undefined ? _data["twoFactorEnabled"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.isAdminUser = _data["isAdminUser"] !== undefined ? _data["isAdminUser"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.isConfirmEmailTokenSent = _data["isConfirmEmailTokenSent"] !== undefined ? _data["isConfirmEmailTokenSent"] : <any>null;
            this.associatedWithPerson = _data["associatedWithPerson"] ? ReadPersonDTO.fromJS(_data["associatedWithPerson"]) : <any>null;
        }
    }

    static fromJS(data: any): ReadUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["isAdminUser"] = this.isAdminUser !== undefined ? this.isAdminUser : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["isConfirmEmailTokenSent"] = this.isConfirmEmailTokenSent !== undefined ? this.isConfirmEmailTokenSent : <any>null;
        data["associatedWithPerson"] = this.associatedWithPerson ? this.associatedWithPerson.toJSON() : <any>null;
        return data;
    }
}

export interface IReadUserDTO {
    id?: number;
    firstName?: string | null;
    lastName?: string | null;
    userName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnabled?: boolean;
    isAdminUser?: boolean;
    lockoutEnd?: Date;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    isConfirmEmailTokenSent?: boolean;
    associatedWithPerson?: ReadPersonDTO;
}

export class ReadUserDTOBaseResponseDTO implements IReadUserDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReadUserDTO[] | null;
    pagedContent?: ReadUserDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReadUserDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReadUserDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReadUserDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReadUserDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReadUserDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReadUserDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReadUserDTO[] | null;
    pagedContent?: ReadUserDTOPagedList;
    errors?: string[] | null;
}

export class ReadUserDTOPagedList implements IReadUserDTOPagedList {
    results?: ReadUserDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReadUserDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReadUserDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReadUserDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReadUserDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReadUserDTOPagedList {
    results?: ReadUserDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RemoveUserFromRoleDTO implements IRemoveUserFromRoleDTO {
    roleName!: string;
    userName!: string;

    constructor(data?: IRemoveUserFromRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): RemoveUserFromRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUserFromRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IRemoveUserFromRoleDTO {
    roleName: string;
    userName: string;
}

export class Report implements IReport {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reasonId?: number;
    statusId?: number;
    personId?: number;
    reportedPersonId?: number | null;
    reviewId?: number | null;
    commentId?: number | null;
    details?: string | null;
    reason?: ReportReason;
    review?: Review;
    comment?: Comment;
    status?: ReportStatus;
    person?: Person;
    reportedPerson?: Person;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.reasonId = _data["reasonId"] !== undefined ? _data["reasonId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reportedPersonId = _data["reportedPersonId"] !== undefined ? _data["reportedPersonId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            this.reason = _data["reason"] ? ReportReason.fromJS(_data["reason"]) : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>null;
            this.status = _data["status"] ? ReportStatus.fromJS(_data["status"]) : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.reportedPerson = _data["reportedPerson"] ? Person.fromJS(_data["reportedPerson"]) : <any>null;
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["reasonId"] = this.reasonId !== undefined ? this.reasonId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reportedPersonId"] = this.reportedPersonId !== undefined ? this.reportedPersonId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        data["reason"] = this.reason ? this.reason.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>null;
        data["status"] = this.status ? this.status.toJSON() : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["reportedPerson"] = this.reportedPerson ? this.reportedPerson.toJSON() : <any>null;
        return data;
    }
}

export interface IReport {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reasonId?: number;
    statusId?: number;
    personId?: number;
    reportedPersonId?: number | null;
    reviewId?: number | null;
    commentId?: number | null;
    details?: string | null;
    reason?: ReportReason;
    review?: Review;
    comment?: Comment;
    status?: ReportStatus;
    person?: Person;
    reportedPerson?: Person;
}

export class ReportDto implements IReportDto {
    reportId?: number;
    reasonId?: number;
    personId?: number;
    reportedPersonId?: number | null;
    reviewId?: number | null;
    commentId?: number | null;
    statusId?: number | null;
    details?: string | null;
    reportType?: string | null;
    createDate?: Date;
    reason?: ReportReasonDto;
    review?: ReviewDto;
    comment?: CommentDetailsDto;
    person?: ReadPersonDTO;
    reportedPerson?: ReadPersonDTO;
    status?: ReportStatusDto;

    constructor(data?: IReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"] !== undefined ? _data["reportId"] : <any>null;
            this.reasonId = _data["reasonId"] !== undefined ? _data["reasonId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.reportedPersonId = _data["reportedPersonId"] !== undefined ? _data["reportedPersonId"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            this.reportType = _data["reportType"] !== undefined ? _data["reportType"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.reason = _data["reason"] ? ReportReasonDto.fromJS(_data["reason"]) : <any>null;
            this.review = _data["review"] ? ReviewDto.fromJS(_data["review"]) : <any>null;
            this.comment = _data["comment"] ? CommentDetailsDto.fromJS(_data["comment"]) : <any>null;
            this.person = _data["person"] ? ReadPersonDTO.fromJS(_data["person"]) : <any>null;
            this.reportedPerson = _data["reportedPerson"] ? ReadPersonDTO.fromJS(_data["reportedPerson"]) : <any>null;
            this.status = _data["status"] ? ReportStatusDto.fromJS(_data["status"]) : <any>null;
        }
    }

    static fromJS(data: any): ReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId !== undefined ? this.reportId : <any>null;
        data["reasonId"] = this.reasonId !== undefined ? this.reasonId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["reportedPersonId"] = this.reportedPersonId !== undefined ? this.reportedPersonId : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        data["reportType"] = this.reportType !== undefined ? this.reportType : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["reason"] = this.reason ? this.reason.toJSON() : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["reportedPerson"] = this.reportedPerson ? this.reportedPerson.toJSON() : <any>null;
        data["status"] = this.status ? this.status.toJSON() : <any>null;
        return data;
    }
}

export interface IReportDto {
    reportId?: number;
    reasonId?: number;
    personId?: number;
    reportedPersonId?: number | null;
    reviewId?: number | null;
    commentId?: number | null;
    statusId?: number | null;
    details?: string | null;
    reportType?: string | null;
    createDate?: Date;
    reason?: ReportReasonDto;
    review?: ReviewDto;
    comment?: CommentDetailsDto;
    person?: ReadPersonDTO;
    reportedPerson?: ReadPersonDTO;
    status?: ReportStatusDto;
}

export class ReportDtoBaseResponseDTO implements IReportDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReportDto[] | null;
    pagedContent?: ReportDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReportDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReportDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReportDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReportDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReportDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReportDto[] | null;
    pagedContent?: ReportDtoPagedList;
    errors?: string[] | null;
}

export class ReportDtoPagedList implements IReportDtoPagedList {
    results?: ReportDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReportDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReportDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReportDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReportDtoPagedList {
    results?: ReportDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReportReason implements IReportReason {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    title?: string | null;
    description?: string | null;
    reports?: Report[] | null;

    constructor(data?: IReportReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["reports"])) {
                this.reports = [] as any;
                for (let item of _data["reports"])
                    this.reports!.push(Report.fromJS(item));
            }
            else {
                this.reports = <any>null;
            }
        }
    }

    static fromJS(data: any): ReportReason {
        data = typeof data === 'object' ? data : {};
        let result = new ReportReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportReason {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    title?: string | null;
    description?: string | null;
    reports?: Report[] | null;
}

export class ReportReasonDto implements IReportReasonDto {
    reasonId?: number;
    title?: string | null;
    description?: string | null;

    constructor(data?: IReportReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reasonId = _data["reasonId"] !== undefined ? _data["reasonId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): ReportReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reasonId"] = this.reasonId !== undefined ? this.reasonId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IReportReasonDto {
    reasonId?: number;
    title?: string | null;
    description?: string | null;
}

export class ReportReasonDtoBaseResponseDTO implements IReportReasonDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReportReasonDto[] | null;
    pagedContent?: ReportReasonDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReportReasonDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReportReasonDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReportReasonDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReportReasonDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReportReasonDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReportReasonDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReportReasonDto[] | null;
    pagedContent?: ReportReasonDtoPagedList;
    errors?: string[] | null;
}

export class ReportReasonDtoPagedList implements IReportReasonDtoPagedList {
    results?: ReportReasonDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReportReasonDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReportReasonDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReportReasonDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReportReasonDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReportReasonDtoPagedList {
    results?: ReportReasonDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReportStatus implements IReportStatus {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    reports?: Report[] | null;

    constructor(data?: IReportStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["reports"])) {
                this.reports = [] as any;
                for (let item of _data["reports"])
                    this.reports!.push(Report.fromJS(item));
            }
            else {
                this.reports = <any>null;
            }
        }
    }

    static fromJS(data: any): ReportStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ReportStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportStatus {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    reports?: Report[] | null;
}

export class ReportStatusDto implements IReportStatusDto {
    statusId?: number;
    name?: string | null;

    constructor(data?: IReportStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ReportStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IReportStatusDto {
    statusId?: number;
    name?: string | null;
}

export class RequestCheckEmailDTO implements IRequestCheckEmailDTO {
    email!: string;

    constructor(data?: IRequestCheckEmailDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): RequestCheckEmailDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCheckEmailDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export interface IRequestCheckEmailDTO {
    email: string;
}

export class RequestCheckUserNameDTO implements IRequestCheckUserNameDTO {
    userName!: string;

    constructor(data?: IRequestCheckUserNameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): RequestCheckUserNameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCheckUserNameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IRequestCheckUserNameDTO {
    userName: string;
}

export class RequestKeycodeDTO implements IRequestKeycodeDTO {
    email!: string;

    constructor(data?: IRequestKeycodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): RequestKeycodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKeycodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export interface IRequestKeycodeDTO {
    email: string;
}

export class ResetPasswordDTO implements IResetPasswordDTO {
    email!: string;
    password!: string;
    rePassword!: string;
    keyCode!: number;

    constructor(data?: IResetPasswordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rePassword = _data["rePassword"] !== undefined ? _data["rePassword"] : <any>null;
            this.keyCode = _data["keyCode"] !== undefined ? _data["keyCode"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rePassword"] = this.rePassword !== undefined ? this.rePassword : <any>null;
        data["keyCode"] = this.keyCode !== undefined ? this.keyCode : <any>null;
        return data;
    }
}

export interface IResetPasswordDTO {
    email: string;
    password: string;
    rePassword: string;
    keyCode: number;
}

export class ResponseGenerateKeycodeDTO implements IResponseGenerateKeycodeDTO {
    isKeycodeSent?: boolean;

    constructor(data?: IResponseGenerateKeycodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isKeycodeSent = _data["isKeycodeSent"] !== undefined ? _data["isKeycodeSent"] : <any>null;
        }
    }

    static fromJS(data: any): ResponseGenerateKeycodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseGenerateKeycodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isKeycodeSent"] = this.isKeycodeSent !== undefined ? this.isKeycodeSent : <any>null;
        return data;
    }
}

export interface IResponseGenerateKeycodeDTO {
    isKeycodeSent?: boolean;
}

export class ResponseGenerateKeycodeDTOBaseResponseDTO implements IResponseGenerateKeycodeDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ResponseGenerateKeycodeDTO[] | null;
    pagedContent?: ResponseGenerateKeycodeDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IResponseGenerateKeycodeDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ResponseGenerateKeycodeDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ResponseGenerateKeycodeDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ResponseGenerateKeycodeDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseGenerateKeycodeDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResponseGenerateKeycodeDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: ResponseGenerateKeycodeDTO[] | null;
    pagedContent?: ResponseGenerateKeycodeDTOPagedList;
    errors?: string[] | null;
}

export class ResponseGenerateKeycodeDTOPagedList implements IResponseGenerateKeycodeDTOPagedList {
    results?: ResponseGenerateKeycodeDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IResponseGenerateKeycodeDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ResponseGenerateKeycodeDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ResponseGenerateKeycodeDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseGenerateKeycodeDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IResponseGenerateKeycodeDTOPagedList {
    results?: ResponseGenerateKeycodeDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Review implements IReview {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    contentId?: number;
    person?: Person;
    content?: Content;
    reviewDetails?: ReviewDetails[] | null;
    comments?: Comment[] | null;
    awards?: AwardPerson[] | null;
    reports?: Report[] | null;
    readonly goldenAwards?: number;
    readonly silverAwards?: number;
    readonly bronzeAwards?: number;

    constructor(data?: IReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.content = _data["content"] ? Content.fromJS(_data["content"]) : <any>null;
            if (Array.isArray(_data["reviewDetails"])) {
                this.reviewDetails = [] as any;
                for (let item of _data["reviewDetails"])
                    this.reviewDetails!.push(ReviewDetails.fromJS(item));
            }
            else {
                this.reviewDetails = <any>null;
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            else {
                this.comments = <any>null;
            }
            if (Array.isArray(_data["awards"])) {
                this.awards = [] as any;
                for (let item of _data["awards"])
                    this.awards!.push(AwardPerson.fromJS(item));
            }
            else {
                this.awards = <any>null;
            }
            if (Array.isArray(_data["reports"])) {
                this.reports = [] as any;
                for (let item of _data["reports"])
                    this.reports!.push(Report.fromJS(item));
            }
            else {
                this.reports = <any>null;
            }
            (<any>this).goldenAwards = _data["goldenAwards"] !== undefined ? _data["goldenAwards"] : <any>null;
            (<any>this).silverAwards = _data["silverAwards"] !== undefined ? _data["silverAwards"] : <any>null;
            (<any>this).bronzeAwards = _data["bronzeAwards"] !== undefined ? _data["bronzeAwards"] : <any>null;
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        if (Array.isArray(this.reviewDetails)) {
            data["reviewDetails"] = [];
            for (let item of this.reviewDetails)
                data["reviewDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.awards)) {
            data["awards"] = [];
            for (let item of this.awards)
                data["awards"].push(item.toJSON());
        }
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        data["goldenAwards"] = this.goldenAwards !== undefined ? this.goldenAwards : <any>null;
        data["silverAwards"] = this.silverAwards !== undefined ? this.silverAwards : <any>null;
        data["bronzeAwards"] = this.bronzeAwards !== undefined ? this.bronzeAwards : <any>null;
        return data;
    }
}

export interface IReview {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    personId?: number;
    contentId?: number;
    person?: Person;
    content?: Content;
    reviewDetails?: ReviewDetails[] | null;
    comments?: Comment[] | null;
    awards?: AwardPerson[] | null;
    reports?: Report[] | null;
    goldenAwards?: number;
    silverAwards?: number;
    bronzeAwards?: number;
}

export class ReviewDetails implements IReviewDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    review?: Review;

    constructor(data?: IReviewDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
            this.review = _data["review"] ? Review.fromJS(_data["review"]) : <any>null;
        }
    }

    static fromJS(data: any): ReviewDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        data["review"] = this.review ? this.review.toJSON() : <any>null;
        return data;
    }
}

export interface IReviewDetails {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    review?: Review;
}

export class ReviewDetailsDto implements IReviewDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    content?: ReadContentDTO;
    comments?: CommentDetailsDto[] | null;
    goldenAwards?: number;
    silverAwards?: number;
    bronzeAwards?: number;
    commentsQuantity?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    createDate?: Date;
    edited?: boolean;

    constructor(data?: IReviewDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.person = _data["person"] ? ReadPersonDTO.fromJS(_data["person"]) : <any>null;
            this.content = _data["content"] ? ReadContentDTO.fromJS(_data["content"]) : <any>null;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDetailsDto.fromJS(item));
            }
            else {
                this.comments = <any>null;
            }
            this.goldenAwards = _data["goldenAwards"] !== undefined ? _data["goldenAwards"] : <any>null;
            this.silverAwards = _data["silverAwards"] !== undefined ? _data["silverAwards"] : <any>null;
            this.bronzeAwards = _data["bronzeAwards"] !== undefined ? _data["bronzeAwards"] : <any>null;
            this.commentsQuantity = _data["commentsQuantity"] !== undefined ? _data["commentsQuantity"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.edited = _data["edited"] !== undefined ? _data["edited"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["goldenAwards"] = this.goldenAwards !== undefined ? this.goldenAwards : <any>null;
        data["silverAwards"] = this.silverAwards !== undefined ? this.silverAwards : <any>null;
        data["bronzeAwards"] = this.bronzeAwards !== undefined ? this.bronzeAwards : <any>null;
        data["commentsQuantity"] = this.commentsQuantity !== undefined ? this.commentsQuantity : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["edited"] = this.edited !== undefined ? this.edited : <any>null;
        return data;
    }
}

export interface IReviewDetailsDto {
    id?: number;
    person?: ReadPersonDTO;
    content?: ReadContentDTO;
    comments?: CommentDetailsDto[] | null;
    goldenAwards?: number;
    silverAwards?: number;
    bronzeAwards?: number;
    commentsQuantity?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
    createDate?: Date;
    edited?: boolean;
}

export class ReviewDetailsDtoBaseResponseDTO implements IReviewDetailsDtoBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: ReviewDetailsDto[] | null;
    pagedContent?: ReviewDetailsDtoPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IReviewDetailsDtoBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ReviewDetailsDto.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? ReviewDetailsDtoPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): ReviewDetailsDtoBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetailsDtoBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IReviewDetailsDtoBaseResponseDTO {
    isSuccess?: boolean;
    content?: ReviewDetailsDto[] | null;
    pagedContent?: ReviewDetailsDtoPagedList;
    errors?: string[] | null;
}

export class ReviewDetailsDtoPagedList implements IReviewDetailsDtoPagedList {
    results?: ReviewDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IReviewDetailsDtoPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReviewDetailsDto.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDetailsDtoPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDetailsDtoPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IReviewDetailsDtoPagedList {
    results?: ReviewDetailsDto[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReviewDto implements IReviewDto {
    id?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;
    commentCount?: number;
    userId?: number | null;
    contentId?: number | null;
    externalContentId?: string | null;
    user?: ReadPersonDTO;

    constructor(data?: IReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
            this.commentCount = _data["commentCount"] !== undefined ? _data["commentCount"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.contentId = _data["contentId"] !== undefined ? _data["contentId"] : <any>null;
            this.externalContentId = _data["externalContentId"] !== undefined ? _data["externalContentId"] : <any>null;
            this.user = _data["user"] ? ReadPersonDTO.fromJS(_data["user"]) : <any>null;
        }
    }

    static fromJS(data: any): ReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        data["commentCount"] = this.commentCount !== undefined ? this.commentCount : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["contentId"] = this.contentId !== undefined ? this.contentId : <any>null;
        data["externalContentId"] = this.externalContentId !== undefined ? this.externalContentId : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data;
    }
}

export interface IReviewDto {
    id?: number | null;
    title?: string | null;
    text?: string | null;
    stars?: number;
    commentCount?: number;
    userId?: number | null;
    contentId?: number | null;
    externalContentId?: string | null;
    user?: ReadPersonDTO;
}

export class SearchDTO implements ISearchDTO {
    page?: number | null;
    results?: SearchResultDTO[] | null;
    total_pages?: number | null;
    total_results?: number | null;

    constructor(data?: ISearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SearchResultDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.total_pages = _data["total_pages"] !== undefined ? _data["total_pages"] : <any>null;
            this.total_results = _data["total_results"] !== undefined ? _data["total_results"] : <any>null;
        }
    }

    static fromJS(data: any): SearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page !== undefined ? this.page : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["total_pages"] = this.total_pages !== undefined ? this.total_pages : <any>null;
        data["total_results"] = this.total_results !== undefined ? this.total_results : <any>null;
        return data;
    }
}

export interface ISearchDTO {
    page?: number | null;
    results?: SearchResultDTO[] | null;
    total_pages?: number | null;
    total_results?: number | null;
}

export class SearchDTOBaseResponseDTO implements ISearchDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: SearchDTO[] | null;
    pagedContent?: SearchDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: ISearchDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(SearchDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? SearchDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): SearchDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ISearchDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: SearchDTO[] | null;
    pagedContent?: SearchDTOPagedList;
    errors?: string[] | null;
}

export class SearchDTOPagedList implements ISearchDTOPagedList {
    results?: SearchDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ISearchDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SearchDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): SearchDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ISearchDTOPagedList {
    results?: SearchDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchResultDTO implements ISearchResultDTO {
    adult?: boolean | null;
    backdrop_path?: string | null;
    genre_ids?: number[] | null;
    id?: number | null;
    original_language?: string | null;
    original_title?: string | null;
    overview?: string | null;
    popularity?: number | null;
    poster_path?: string | null;
    release_date?: string | null;
    title?: string | null;
    video?: boolean | null;
    vote_average?: number | null;
    vote_count?: number | null;

    constructor(data?: ISearchResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adult = _data["adult"] !== undefined ? _data["adult"] : <any>null;
            this.backdrop_path = _data["backdrop_path"] !== undefined ? _data["backdrop_path"] : <any>null;
            if (Array.isArray(_data["genre_ids"])) {
                this.genre_ids = [] as any;
                for (let item of _data["genre_ids"])
                    this.genre_ids!.push(item);
            }
            else {
                this.genre_ids = <any>null;
            }
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.original_language = _data["original_language"] !== undefined ? _data["original_language"] : <any>null;
            this.original_title = _data["original_title"] !== undefined ? _data["original_title"] : <any>null;
            this.overview = _data["overview"] !== undefined ? _data["overview"] : <any>null;
            this.popularity = _data["popularity"] !== undefined ? _data["popularity"] : <any>null;
            this.poster_path = _data["poster_path"] !== undefined ? _data["poster_path"] : <any>null;
            this.release_date = _data["release_date"] !== undefined ? _data["release_date"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.video = _data["video"] !== undefined ? _data["video"] : <any>null;
            this.vote_average = _data["vote_average"] !== undefined ? _data["vote_average"] : <any>null;
            this.vote_count = _data["vote_count"] !== undefined ? _data["vote_count"] : <any>null;
        }
    }

    static fromJS(data: any): SearchResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adult"] = this.adult !== undefined ? this.adult : <any>null;
        data["backdrop_path"] = this.backdrop_path !== undefined ? this.backdrop_path : <any>null;
        if (Array.isArray(this.genre_ids)) {
            data["genre_ids"] = [];
            for (let item of this.genre_ids)
                data["genre_ids"].push(item);
        }
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["original_language"] = this.original_language !== undefined ? this.original_language : <any>null;
        data["original_title"] = this.original_title !== undefined ? this.original_title : <any>null;
        data["overview"] = this.overview !== undefined ? this.overview : <any>null;
        data["popularity"] = this.popularity !== undefined ? this.popularity : <any>null;
        data["poster_path"] = this.poster_path !== undefined ? this.poster_path : <any>null;
        data["release_date"] = this.release_date !== undefined ? this.release_date : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["video"] = this.video !== undefined ? this.video : <any>null;
        data["vote_average"] = this.vote_average !== undefined ? this.vote_average : <any>null;
        data["vote_count"] = this.vote_count !== undefined ? this.vote_count : <any>null;
        return data;
    }
}

export interface ISearchResultDTO {
    adult?: boolean | null;
    backdrop_path?: string | null;
    genre_ids?: number[] | null;
    id?: number | null;
    original_language?: string | null;
    original_title?: string | null;
    overview?: string | null;
    popularity?: number | null;
    poster_path?: string | null;
    release_date?: string | null;
    title?: string | null;
    video?: boolean | null;
    vote_average?: number | null;
    vote_count?: number | null;
}

export class SpokenLanguageDTO implements ISpokenLanguageDTO {
    english_name?: string | null;
    iso_639_1?: string | null;
    name?: string | null;

    constructor(data?: ISpokenLanguageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.english_name = _data["english_name"] !== undefined ? _data["english_name"] : <any>null;
            this.iso_639_1 = _data["iso_639_1"] !== undefined ? _data["iso_639_1"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SpokenLanguageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SpokenLanguageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["english_name"] = this.english_name !== undefined ? this.english_name : <any>null;
        data["iso_639_1"] = this.iso_639_1 !== undefined ? this.iso_639_1 : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ISpokenLanguageDTO {
    english_name?: string | null;
    iso_639_1?: string | null;
    name?: string | null;
}

export class StringBaseResponseDTO implements IStringBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: string[] | null;
    pagedContent?: StringPagedList;
    readonly errors?: string[] | null;

    constructor(data?: IStringBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(item);
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? StringPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): StringBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item);
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IStringBaseResponseDTO {
    isSuccess?: boolean;
    content?: string[] | null;
    pagedContent?: StringPagedList;
    errors?: string[] | null;
}

export class StringPagedList implements IStringPagedList {
    results?: string[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IStringPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): StringPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new StringPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IStringPagedList {
    results?: string[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Tier implements ITier {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isPremium?: boolean;
    tierPlans?: TierPlan[] | null;

    constructor(data?: ITier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isPremium = _data["isPremium"] !== undefined ? _data["isPremium"] : <any>null;
            if (Array.isArray(_data["tierPlans"])) {
                this.tierPlans = [] as any;
                for (let item of _data["tierPlans"])
                    this.tierPlans!.push(TierPlan.fromJS(item));
            }
            else {
                this.tierPlans = <any>null;
            }
        }
    }

    static fromJS(data: any): Tier {
        data = typeof data === 'object' ? data : {};
        let result = new Tier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isPremium"] = this.isPremium !== undefined ? this.isPremium : <any>null;
        if (Array.isArray(this.tierPlans)) {
            data["tierPlans"] = [];
            for (let item of this.tierPlans)
                data["tierPlans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITier {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    isPremium?: boolean;
    tierPlans?: TierPlan[] | null;
}

export class TierPlan implements ITierPlan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    tierId?: number;
    timespanId?: number;
    price?: number;
    tier?: Tier;
    timespan?: Timespan;
    premiumPerson?: PremiumPerson[] | null;

    constructor(data?: ITierPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.tierId = _data["tierId"] !== undefined ? _data["tierId"] : <any>null;
            this.timespanId = _data["timespanId"] !== undefined ? _data["timespanId"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.tier = _data["tier"] ? Tier.fromJS(_data["tier"]) : <any>null;
            this.timespan = _data["timespan"] ? Timespan.fromJS(_data["timespan"]) : <any>null;
            if (Array.isArray(_data["premiumPerson"])) {
                this.premiumPerson = [] as any;
                for (let item of _data["premiumPerson"])
                    this.premiumPerson!.push(PremiumPerson.fromJS(item));
            }
            else {
                this.premiumPerson = <any>null;
            }
        }
    }

    static fromJS(data: any): TierPlan {
        data = typeof data === 'object' ? data : {};
        let result = new TierPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["tierId"] = this.tierId !== undefined ? this.tierId : <any>null;
        data["timespanId"] = this.timespanId !== undefined ? this.timespanId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["tier"] = this.tier ? this.tier.toJSON() : <any>null;
        data["timespan"] = this.timespan ? this.timespan.toJSON() : <any>null;
        if (Array.isArray(this.premiumPerson)) {
            data["premiumPerson"] = [];
            for (let item of this.premiumPerson)
                data["premiumPerson"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITierPlan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    tierId?: number;
    timespanId?: number;
    price?: number;
    tier?: Tier;
    timespan?: Timespan;
    premiumPerson?: PremiumPerson[] | null;
}

export class Timespan implements ITimespan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    days?: number;
    tierPlans?: TierPlan[] | null;

    constructor(data?: ITimespan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.uuid = _data["uuid"] !== undefined ? _data["uuid"] : <any>null;
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>null;
            this.alterDate = _data["alterDate"] ? new Date(_data["alterDate"].toString()) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.days = _data["days"] !== undefined ? _data["days"] : <any>null;
            if (Array.isArray(_data["tierPlans"])) {
                this.tierPlans = [] as any;
                for (let item of _data["tierPlans"])
                    this.tierPlans!.push(TierPlan.fromJS(item));
            }
            else {
                this.tierPlans = <any>null;
            }
        }
    }

    static fromJS(data: any): Timespan {
        data = typeof data === 'object' ? data : {};
        let result = new Timespan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["uuid"] = this.uuid !== undefined ? this.uuid : <any>null;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>null;
        data["alterDate"] = this.alterDate ? this.alterDate.toISOString() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["days"] = this.days !== undefined ? this.days : <any>null;
        if (Array.isArray(this.tierPlans)) {
            data["tierPlans"] = [];
            for (let item of this.tierPlans)
                data["tierPlans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITimespan {
    id?: number;
    uuid?: string | null;
    createDate?: Date;
    alterDate?: Date | null;
    active?: boolean;
    name?: string | null;
    days?: number;
    tierPlans?: TierPlan[] | null;
}

export class TokenDTO implements ITokenDTO {
    accessToken?: string | null;
    refreshToken?: string | null;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;

    constructor(data?: ITokenDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
            this.accessTokenExpiration = _data["accessTokenExpiration"] ? new Date(_data["accessTokenExpiration"].toString()) : <any>null;
            this.refreshTokenExpiration = _data["refreshTokenExpiration"] ? new Date(_data["refreshTokenExpiration"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TokenDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        data["accessTokenExpiration"] = this.accessTokenExpiration ? this.accessTokenExpiration.toISOString() : <any>null;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration ? this.refreshTokenExpiration.toISOString() : <any>null;
        return data;
    }
}

export interface ITokenDTO {
    accessToken?: string | null;
    refreshToken?: string | null;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;
}

export class TokenDTOBaseResponseDTO implements ITokenDTOBaseResponseDTO {
    readonly isSuccess?: boolean;
    readonly content?: TokenDTO[] | null;
    pagedContent?: TokenDTOPagedList;
    readonly errors?: string[] | null;

    constructor(data?: ITokenDTOBaseResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(TokenDTO.fromJS(item));
            }
            else {
                (<any>this).content = <any>null;
            }
            this.pagedContent = _data["pagedContent"] ? TokenDTOPagedList.fromJS(_data["pagedContent"]) : <any>null;
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
            else {
                (<any>this).errors = <any>null;
            }
        }
    }

    static fromJS(data: any): TokenDTOBaseResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTOBaseResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["pagedContent"] = this.pagedContent ? this.pagedContent.toJSON() : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface ITokenDTOBaseResponseDTO {
    isSuccess?: boolean;
    content?: TokenDTO[] | null;
    pagedContent?: TokenDTOPagedList;
    errors?: string[] | null;
}

export class TokenDTOPagedList implements ITokenDTOPagedList {
    results?: TokenDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ITokenDTOPagedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TokenDTO.fromJS(item));
            }
            else {
                this.results = <any>null;
            }
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): TokenDTOPagedList {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDTOPagedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ITokenDTOPagedList {
    results?: TokenDTO[] | null;
    pageCount?: number;
    pageSize?: number;
    page?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UpdateCommentDto implements IUpdateCommentDto {
    commentId?: number;
    text?: string | null;

    constructor(data?: IUpdateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commentId = _data["commentId"] !== undefined ? _data["commentId"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId !== undefined ? this.commentId : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        return data;
    }
}

export interface IUpdateCommentDto {
    commentId?: number;
    text?: string | null;
}

export class UpdateReportStatusDto implements IUpdateReportStatusDto {
    reportId?: number;
    statusId?: number;

    constructor(data?: IUpdateReportStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"] !== undefined ? _data["reportId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateReportStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReportStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId !== undefined ? this.reportId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        return data;
    }
}

export interface IUpdateReportStatusDto {
    reportId?: number;
    statusId?: number;
}

export class UpdateReviewDto implements IUpdateReviewDto {
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;

    constructor(data?: IUpdateReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.stars = _data["stars"] !== undefined ? _data["stars"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["stars"] = this.stars !== undefined ? this.stars : <any>null;
        return data;
    }
}

export interface IUpdateReviewDto {
    reviewId?: number;
    title?: string | null;
    text?: string | null;
    stars?: number;
}

export class UpdateUserDTO implements IUpdateUserDTO {
    userName?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    personDetails!: PersonOnCreateUserDTO;

    constructor(data?: IUpdateUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personDetails = new PersonOnCreateUserDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.personDetails = _data["personDetails"] ? PersonOnCreateUserDTO.fromJS(_data["personDetails"]) : new PersonOnCreateUserDTO();
        }
    }

    static fromJS(data: any): UpdateUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["personDetails"] = this.personDetails ? this.personDetails.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateUserDTO {
    userName?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    personDetails: PersonOnCreateUserDTO;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}